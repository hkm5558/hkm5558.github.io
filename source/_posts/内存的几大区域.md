title: 内存的几大区域
date: 2017-11-17 17:51:33
tags: [内存, iOS]
categories: Question
---

## 1. 栈区(stack)
> 栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］

栈空间分静态分配 和动态分配两种。
> 静态分配是编译器完成的，比如自动变量(auto)的分配。  
动态分配由alloca函数完成。  
栈的动态分配无需释放(是自动的)，也就没有释放函数。  
为可移植的程序起见，栈的动态分配操作是不被鼓励的。

## 2. 堆区(heap)


> 堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。   

优点是灵活方便，数据适应面广泛，但是效率有一定降低。

> 堆是函数库内部数据结构，不一定唯一。  
不同堆分配的内存无法互相操作。  
堆的分配总是动态的。

虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。

## 3. 全局区(静态区) (static)


> 全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。

> 注意：全局区又可分为**未初始化全局区**(bss段)和**初始化全局区**(data段)  
 举例:   
 `int a; 未初始化的`  `int a = 10; 初始化的`
 

4. 文字常量区
------------

 > 文字常量区 存放常量字符串，程序结束后由系统释放；

5. 代码区
------------

> 代码区 存放函数的二进制代码

{% asset_img pic1.jpg 图片来源见水印 %}


{% asset_img pic2.jpg 图片来源见水印 %}


  
例子代码：
{% asset_img pic3.jpg 图片来源见水印 %}

## 可能被追问的问题一：

> * 栈区 (stack [stæk]): 
> 由编译器自动分配释放  
> 局部变量是保存在栈区的  
> 方法调用的实参也是保存在栈区的

> * 堆区 (heap [hiːp]):   
> 由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！

> * BSS 段 :   
> 程序结束后由系统释放

> * 数据段 :   
> 程序结束后由系统释放

> * 代码段:  
> 程序结束后由系统释放
> 程序编译链接 后的二进制可执行代码

## 可能被追问的问题二：

> * 申请后的系统是如何响应的？
> > 栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。
>>
> > 注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。  
>>
>> 堆：  
>> 1.首先应该知道操作系统有一个记录空闲内存地址的链表。  
>> 2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。  
>> 3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中

## 可能被追问的问题三：

> * 申请大小的限制是怎样的？
> > 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。  
> > 是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。  
> > 因此，能从栈获得的空间较小。
>>
>> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。  
>> 这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。  
>> 堆的大小受限于计算机系统中有效的虚拟内存。  
>> 由此可见，堆获得的空间比较灵活，也比较大。
>>
>> {% asset_img pic4.png 图片来源见水印 %}
>>  栈：  
>>  由系统自动分配，速度较快，不会产生内存碎片  
>>  
>>  堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便  
>>  打个比喻来说：  
>>  使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。  
>>  使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

