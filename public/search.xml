<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用NSTimer时该注意什么]]></title>
    <url>%2F2018%2F01%2F03%2F%E4%BD%BF%E7%94%A8NSTimer%E6%97%B6%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[NSTimer的常用API 1234+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo; ///Initializes a timer object with the specified object and selector.+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo; /// Creates a timer and schedules it on the current run loop in the default mode. 根据官方文档方法一和方法二的区别在于：使用方法一创建的Timer不会添加到NSRunLoop需要手动添加；使用方法二会自动添加到主线程的RunLoop中。 1234- (void)fire; ///Causes the timer's message to be sent to its target.- (void)invalidate; ///Stops the timer from ever firing again and requests its removal from its run loop. fire方法可以立即触发Timer对象的target方法；invalidate会停止Timer并将其从runloop中移除 NSRunLoop &amp; NSTimer当使用NSTimer的scheduledTimerWithTimeInterval方法时，NSTimer的实例会被加入到当前线程的RunLoop中，模式为默认模式NSDefaultRunLoopMode。123456789101112131415- (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@"主线程 %@", [NSThread currentThread]); NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(doSomething) userInfo:nil repeats:YES]; //使用NSRunLoopCommonModes模式，把timer加入到当前Run Loop中。 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&#125;- (void)doSomething&#123; NSLog(@"Timer %@", [NSThread currentThread]); //控制台输出结果：上下打印出来的线程都是主线程&#125; 如果当你线程是主线程也就是UI线程时，某些UI事件（UIScrollView的滑动操作），会将RunLoop切换到NSEventTrackingRunLoopMode模式。在这个过程中，默认的NSDefaultRunLoopMode模式中注册的事件是不会被执行的。也就是说，此时使用scheduledTimerWithTimeInterval添加到RunLoop中的Timer就不会执行。这是一个在开发中经常碰到的场景，如何解决这个问题？我们可以在创建完一个Timer后使用NSRunLoop的addTimer:forMode:方法，使用NSRunLoopCommonModes。这是一个占位用的Mode，可以在不同情况下扮演不同的角色——NSDefaultRunLoopMode &amp; UITrackingRunLoopMode。 NSTimer循环引用问题NSTimer为什么会造成循环引用？在开发中我们经常将Timer作为控制器的属性来使用，这样一来控制器对Timer进行了强引用。在target-action这个过程中，Timer又对self做了强引用，这就是导致循环引用的原因了。在网上有非常多的解决方案，总结了一下有下面几种。 方法一：在viewWillDisappear中执行下面的操作。 123456 - (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [_timer invalidate]; _timer = nil;&#125; 苹果文档中关于target强引用的解释123456789- (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)target selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats Parameters ti The number of seconds between firings of the timer. If ti is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead. target The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated. The timer maintains a strong reference to this object until it (the timer) is invalidated.苹果文档说invalidate以后timer就不再保有对target的强引用了。所以解决循环引用的关键在于invalidate方法有没有执行。下面_timer = nil这句话的意义是，invalidate方法执行以后Timer就不能复用了，为了防止在其之后其他地方再次使用Timer，在这里将其置为nil。 方法二：引入一个代理对象，让其弱引用self，参考YYWeakProxy没引入代理(Proxy)之前是：self -&gt; timer -&gt; self这样的循环引用。在引入代理(Proxy)之后是：self -&gt; timer -&gt; proxy ··&gt; self。这样一来就打破了之前的循环引用。 方法三：使用YYTimer和MSWeakTimer等GCD实现的Timer。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于class_copyIvarList方法]]></title>
    <url>%2F2017%2F12%2F18%2F%E5%85%B3%E4%BA%8Eclass-copyIvarList%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在runtime.h中，你可以通过其中的class_copyIvarList方法来获取实例变量。具体的实现如下（记得导入头文件#import &lt;objc/runtime.h&gt;） 12345678910111213141516- (NSArray *)ivarArray:(Class)cls &#123; unsigned int ivarCount = 0; Ivar *ivars = class_copyIvarList(cls, &amp;ivarCount); if (stuIvarCount == 0) &#123; return nil; &#125; NSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:ivarCount]; for (int i = 0;i&lt;ivarCount;i++) &#123; Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSLog(@"%@",ivarName); [arr addObject:ivarName]; &#125; free(ivars); return arr;&#125; 如上面代码。其中cls就是你要获取实例变量的类，ivarCount用来承载要获取类的实例变量的个数。打印出来的ivarName就是cls的实例变量。接下来对这个方法进行解析:首先看一下里面的Ivar,先看一下定义： 12345678910/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;struct objc_ivar &#123; char * _Nullable ivar_name OBJC2_UNAVAILABLE; //变量名字 char * _Nullable ivar_type OBJC2_UNAVAILABLE; //变量类型 int ivar_offset OBJC2_UNAVAILABLE; //偏移量 #ifdef __LP64__ int space OBJC2_UNAVAILABLE; //存储空间 #endif&#125; Ivar是一个叫做objc_ivar的结构体指针,其中的 ifdef判断是判断当前设备是否是64位设备，这里可以延伸出一个方法： 12345678//判断当前设备是否是64位设备，也可以用这个方法判断是否是32位设备- (BOOL)is64Bit &#123; #if defined(__LP64__) &amp;&amp; __LP64__ return YES; #else return NO; #endif&#125; 123OBJC_EXPORT Ivar _Nonnull * _Nullableclass_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_copyIvarList的注释如下： 它返回的是一个Ivar的数组，这个数组里面包含了你要查看类的所有实例变量，但是不包括从父类继承过来的。如果你传入的类没有实例变量或者该class为Nil,那么该方法返回的就是NULL，count值也就变成了0。有一点需要注意：你必须使用free()方法将该数组释放。然后就是通过for循环遍历，通过ivar _ getName拿到ivarName。以上便是对clas_copyIvarList的介绍。它还有一个最常用的使用方式（在开发中经常用到的）：根据字典或者json字符串转化为model，在网络请求返回数据时经常用到。使用方法就是自己写一个基类的model，然后让项目中用到的model都继承自此基类，基类中的关键代码如下： 1234567891011121314151617+ (instancetype)km_modelFromDic:(NSDictionary *)dataDic &#123; id model = [[self alloc] init]; unsigned int count = 0; Ivar *ivarsA = class_copyIvarList(self, &amp;count); if (count == 0) &#123; return model; &#125; for (int i = 0;i &lt; count; i++) &#123; Ivar iv = ivarsA[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(iv)]; ivarName = [ivarName substringFromIndex:1]; id value = dataDic[ivarName]; [model setValue:value forKey:ivarName]; &#125; free(ivarsA); return model;&#125; 这里是把字典转成model，先用class_copyIvar获取该model的所有实例变量,然后通过kvc对属性进行赋值。最终返回model。这里有个点需要注意以下几点： 你的model的属性名称要和服务端返回的数据一致，比如你的model有个属性叫做name，那么你服务端返回的数据字典里面的对应属性也要叫做name，因为这个方法是根据属性从字典里面拿数据的。你也可以做一个映射，让自定义的实例变量名称映射到服务端提供的变量名称。 实现里面有个substringFromIndex：操作，其目的就是把使用该方法拿到的实例变量前面的” “去掉。所以你最好使用 @property 进行属性声明，并且不要去修改自动生成的实例变量。（@property = getter + setter + ` ivar，这里的_ ivar`其实就是编译器帮我们生成的实例变量） 接下来你可以尝试去获取UILabel的实例变量列表：1[self ivarArray:[UILabel class]] 你会发现拿到的结果是这样的： 123456789101112131415161718192021222324252627282930( &quot;_size&quot;, &quot;_highlightedColor&quot;, &quot;_numberOfLines&quot;, &quot;_measuredNumberOfLines&quot;, &quot;_baselineReferenceBounds&quot;, &quot;_lastLineBaseline&quot;, &quot;_previousBaselineOffsetFromBottom&quot;, &quot;_firstLineBaseline&quot;, &quot;_previousFirstLineBaseline&quot;, &quot;_minimumScaleFactor&quot;, &quot;_content&quot;, &quot;_synthesizedAttributedText&quot;, &quot;_defaultAttributes&quot;, &quot;_fallbackColorsForUserInterfaceStyle&quot;, &quot;_minimumFontSize&quot;, &quot;_lineSpacing&quot;, &quot;_layout&quot;, &quot;_scaledMetrics&quot;, &quot;_cachedIntrinsicContentSize&quot;, &quot;_contentsFormat&quot;, &quot;_cuiCatalog&quot;, &quot;_cuiStyleEffectConfiguration&quot;, &quot;_textLabelFlags&quot;, &quot;_adjustsFontForContentSizeCategory&quot;, &quot;__textColorFollowsTintColor&quot;, &quot;_preferredMaxLayoutWidth&quot;, &quot;_multilineContextWidth&quot;, &quot;__visualStyle&quot;) 但是跳转到UILabel.h，你会发现里面有好多的属性不包含在我们根据该方法得出的属性数组里面，而且使用该方法得到的属性在UILabel.h里面并没有。这个是什么原因呢？先看一下好多UILabel里面的属性没有在数组里面打印的问题：猜想应该是在UILabel.m里面使用了 @dynamic。导致没有自动生成getter、setter和ivar，所以没有在数组里面包含。 @synthsize：如果没有手动实现setter/getter方法那么会自动生成，自动生成_var变量。如果不写，默认生成getter/setter和_var。你也可以使用该关键字自己设置自动变量的名称。@dynamic告诉编译器：属性的setter/getter需要用户自己实现，不自动生成，而且也不会产生_var变量。 也就是说在UILabel里面虽然有个text的属性，也许在UILabel.m里面已经包含：1@dynamic text; 这样的话在实现里面没有产生实例变量，只是手动实现了getter和setter，所以就不会显示text属性在刚才得到的数组里面了。至于数组中有UILabel.h里面没有的变量，这个就好理解了，有可能在UILabel.m里面添加了一些实例变量或者在运行时添加了这些实例变量。 除此方法之外，你还可以使用class_copyPropertyList方法，这个是拿到的所有用 @property 声明的属性,包括在.m里面添加的属性（所以打印出来的可能要比真实在.h里面看到的多），具体实现和上面的获取方法类似： 123456789101112131415- (NSArray *)propertyArr:(Class)cls &#123; unsigned count = 0; objc_property_t *properties = class_copyPropertyList(cls, &amp;count); if (count == 0) &#123; return nil; &#125; NSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:count]; for (int i = 0; i &lt; count; i ++) &#123; objc_property_t property = properties[i]; NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)] ; [arr addObject:propertyName]; &#125; free(properties); return arr;&#125; 其中的copyPropertyList方法解释如下： 记得使用过后也要调用free去释放数组。（PS：在源代码中暂未找到objc_property结构体的说明）因此，你可以通过使用该方法来实现字典或者json字符串转model操作： 12345678910111213141516+ (instancetype)km_modelFromDic:(NSDictionary *)dataDic &#123; id model = [[self alloc] init]; unsigned int count = 0; objc_property_t *properties = class_copyPropertyList([self class], &amp;count); if (count == 0) &#123; return model; &#125; for (int i = 0;i &lt; count; i++) &#123; objc_property_t property = properties[i]; NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; id value = dataDic[propertyName]; [model setValue:value forKey:propertyName]; &#125; free(properties); return model;&#125; 两种方式均可实现字典到model的转换操作。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中enum、struct、class三者异同]]></title>
    <url>%2F2017%2F11%2F29%2FSwift%E4%B8%ADenum%E3%80%81struct%E3%80%81class%E4%B8%89%E8%80%85%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[写在前面由于在开发过程中常常需要用到系统提供的基础类型之外的的类型，所以Swift允许我们根据自己的需要构建属于自己的类型系统以便于更加灵活和方便的开发程序并将其称之为named types。Swift主要为我们提供了以下四种named types 分别是：enum、struct、class和protocol， 相信熟悉objective-c开发的同学们对于iOS中枚举、结构体和类的概念一点都不陌生。相比于objective-c中的这三者，Swift将enum和struct变得更加灵活且强大，并且赋予了他们很多和class相同的属性实现更加丰富多彩的功能，以至于有时候我们很难分清他们到底有什么区别以及我该什么时候用哪种类型，接下来本文将介绍在Swift中enum和struct的定义和新特性以及两者与class之间的异同。 枚举（enum） 枚举的定义Swift中的枚举是为一组有限种可能性的相关值提供的通用类型（在C/C++/C#中，枚举是一个被命名的整型常数的集合）；使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词enum来定义枚举，并在一对大括号内定义具体内容包括使用case关键字列举成员。就像下面一样： 123456//定义一个表示学生类型的全新枚举类型 StudentType，他有三个成员分别是pupil（小学生，）、middleSchoolStudent（中学生）、collegeStudents（大学生）enum StudentType &#123; case pupil case middleSchoolStudent case collegeStudent&#125; 上面的代码可以读作：如果存在一个StudentType的实例，他要么是pupil （小学生）、要么是middleSchoolStudent（中学生）、要么是collegeStudent（大学生）。注意，和C、objective-c中枚举的不同，Swift 中的枚举成员在被创建时不会分配一个默认的整数值。而且不需要给枚举中的每一个成员都提供值(如果你需要也是可以的)。如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型（引自文档翻译）。简单说Swift中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值（不局限于整数类型）。枚举中有两个很容易混淆的概念：原始值(raw value)、关联值(associated value)，两个词听起来比较模糊，下面简单介绍一下： 枚举的原始值(raw value)枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(raw value)，下面的StudentType中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。注意：Int修饰的是StudentType成员原始值的类型而不是StudentType的类型，StudentType类型从定义开始就是一个全新的枚举类型。 12345enum StudentType: Int&#123; case pupil = 10 case middleSchoolStudent = 15 case collegeStudents = 20&#125; 定义好StudentType成员的原始值之后，我们可以使用枚举成员的rawValue属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例 12345678910// 常量student1值是 10let student1 = StudentType.pupil.rawValue// 变量student2值是 15var student2 = StudentType.middleSchoolStudent.rawValue// 使用成员rawValue属性创建一个`StudentType`枚举的新实例let student3 = StudentType.init(rawValue: 15)// student3的值是 Optional&lt;senson&gt;.Typetype(of: student3)// student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值let student4 = StudentType.init(rawValue: 30) 使用原始值初始化器这种方式初始化创建得到StudentType的实例student4是一个StudentType的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在StudentType中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。 枚举的关联值(associated value)关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码 123456//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudentsenum StudentType &#123; case pupil(String) case middleSchoolStudent(Int, String) case collegeStudents(Int, String)&#125; 这里我们并没有为StudentType的成员提供具体的值，而是为他们绑定了不同的类型，分别是pupil绑定String类型、middleSchoolStudent和collegeStudents绑定（Int， String）元组类型。接下来就可以创建不同StudentType枚举实例并为对应的成员赋值了。123456//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是"have fun"（总是在玩耍）let student1 = StudentType.pupil("have fun") //student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, "always study"（一周7天总是在学习）let student2 = StudentType.middleSchoolStudent(7, "always study") //student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, "always LOL"（一周7天总是在撸啊撸）let student3 = StudentType.middleSchoolStudent(7, "always LOL") 这个时候如果需要判断某个StudentType实例的具体的值就需要这样做了： 12345678switch student3 &#123; case .pupil(let things): print("is a pupil and \(things)") case .middleSchoolStudent(let day, let things): print("is a middleSchoolStudent and \(day) days \(things)") case .collegeStudent(let day, let things): print("is a collegeStudent and \(day) days \(things)") &#125; 控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。 递归枚举递归枚举是拥有另一个枚举作为枚举成员关联值的枚举（引自文档翻译）。关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。下面是一个经典的通过递归算法求解n!（阶乘）的函数。 123456789func factorial(n: Int)-&gt;Int &#123; if n &gt; 0 &#123; return n * factorial(n: n - 1) &#125; else &#123; return 1 &#125;&#125;//1 * 2 * 3 * 4 * 5 * 6 = 720let sum = factorial(n: 6) 函数factorial (n: int)-&gt; Int在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。 结构体（struct） 结构体的定义结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在Swift中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。我们通过使用关键词struct来定义结构体。并在一对大括号内定义具体内容包括他的成员和自定义的方法（是的，Swift中的结构体有方法了），定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。废话不多说直接上代码: 123456//定义一个 Student（学生）类型的结构体用于表示一个学生，Student的成员分别是语、数、外三科`Int`类型的成绩struct Student &#123; var chinese: Int var math: Int var english: Int&#125; 看到这里熟悉Swift的同学可能已经发现了一点结构体和类的区别了：定义结构体类型时其成员可以没有初始值。如果使用这种格式定义一个类，编译器是会报错的，他会提醒你这个类没有被初始化。 结构体实例的创建创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。最简单的语法是在类或结构体名字后面接一个空的圆括号，例如 let student1 = Student()。这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。但是结合上面的代码，由于在定义Student结构体时我们并没有为他的成员赋初值，所以 let student1 = Student()在编译器中报错了，此处报错并不是因为不能这样创建实例而是因为student1成员没有默认值，所以我们可以使用下面的方式创建实例: 12//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）let student2 = Student(chinese: 90, math: 80, english: 70) 所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义Student时为他的成员赋上初值，那么下面的代码是编译通过的： 1234567struct Student &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50&#125;let student2 = Student(chinese: 90, math: 80, english: 70)let student4 = Student() 总结一句：定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。 自定义的初始化器当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过形如 let student5 = Student(stringScore: &quot;70,80,90&quot;) 的方式创建实例时，就需要自定义初始化方法了： 1234567891011121314151617181920struct Student &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50 init() &#123;&#125; init(chinese: Int, math: Int, english: Int) &#123; self.chinese = chinese self.math = math self.english = english &#125; init(stringScore: String) &#123; let cme = stringScore.characters.split(separator: ",") chinese = Int(atoi(String(cme.first!))) math = Int(atoi(String(cme[1]))) english = Int(atoi(String(cme.last!))) &#125; &#125; let student6 = Student() let student7 = Student(chinese: 90, math: 80, english: 70) let student8 = Student(stringScore: "70,80,90") 一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。 定义其他方法如果此时需要修改某个学生某科的成绩，该如何实现呢？当然，我们可以定义下面的方法： 12345//更改某个学生某门学科的成绩func changeChinese(num: Int, student: inout Student)&#123; student.chinese += num&#125;changeChinese(num: 20, student: &amp;student7) 此时student7的语文成绩就由原来的90被修改到了110，但是此方法有两个明显的弊端：1，学生的语文成绩chinese是Student结构体的内部成员，一个学生的某科成绩无需被Student的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。2，更改一个学生的语文成绩本身就是和Student结构体内部成员计算相关的事情，我们更希望达到形如：student7.changeChinese(num: 10) 的效果，因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时changeChinese(num:)方法是Student结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比： 12345678910111213141516struct Student &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50 //修改数学成绩 mutating func changeMath(num: Int) &#123; self.math += num &#125; &#125; var student7 = Student(chinese: 20, math: 30, english: 40) //更改分数中语文学科的成绩 func changeChinese(num: Int, student: inout Student)&#123; student.chinese += num &#125; changeChinese(num: 20, student: &amp;student7) student7.changeMath(num: 10) 尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为Student结构体内部添加changeMath(num:)的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：mutating关键字。由于结构体是值类型，Swift规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用mutating我们便可以办到这点，当然这也是和类的不同点。 常见的结构体Swift中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型： 12345678//表示数值类型的结构体： Int，Float，Double，CGFloat...//表示字符和字符串类型的结构体 Character，String...//位置和尺寸的结构体 CGPoint，CGSize...//集合类型结构体 Array，Set，Dictionary... 很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况 12345678// Person 类class Person &#123; var name: String = "jack" let life: Int = 1&#125; var s1 = Person() var s2 = s1 s2.name = "mike" 12345678// People 结构体数据结构struct People &#123; var name: String = "jack" let life: Int = 1&#125; var p1 = People() var p2 = p1 p2.name = "mike" 细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是因为 struct 是值引用，class 是类型引用。 总结 枚举、结构体、类的共同点： 定义属性和方法； 下标语法访问值； 初始化器； 支持扩展增加功能； 可以遵循协议； 类特有的功能； 继承； 允许类型转换； 析构方法释放资源； 引用计数； 类是引用类型 引用类型(reference types，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。 枚举，结构体是值类型 值类型(value types)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。 该如何选择 关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）： 当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：1.什么时候该用值类型：要用==运算符来比较实例的数据时你希望那个实例的拷贝能保持独立的状态时数据会被多个线程使用时2.什么时候该用引用类型（class）：要用==运算符来比较实例身份的时候你希望有创建一个共享的、可变对象的时候]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Class</tag>
        <tag>Enum</tag>
        <tag>Struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage基本原理]]></title>
    <url>%2F2017%2F11%2F29%2FSDWebImage%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。 2. 进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo: 交给 SDImageCache 从缓存查找图片是否已经下载queryDiskCacheForKey:delegate:userInfo: 3. 先从内存图片缓存查找是否有图片 如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager，SDWebImageManagerDelegate回调 webImageManager:didFinishWithImage:到 UIImageView+WebCache 等前端展示图片 4. 如果内存缓存中没有 生成 NSInvocationOperation添加到队列开始从硬盘查找图片是否已经缓存 5. 根据 URLKey 在硬盘缓存目录下尝试读取图片文件 这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate: 6. 如果从硬盘读取到了图片 将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存），SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片 7. 如果从硬盘缓存目录读取不到图片 说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo: 8. 下载图片 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果 9. 数据下载完成 connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理 10. 图片解码 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。 11. 解码完成 在主线程 notifyDelegateOnMainThreadWithInfo:宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo:回调给 SDWebImageDownloader。 12. 图片下载完成 imageDownloader:didFinishWithImage:回调给 SDWebImageManager 告知图片下载完成。通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。 13. 缓存图片 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 14. 其他 SDImageCache 在初始化的时候会注册一些消息通知在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。 SDWebImage 也提供了 UIButton+WebCache 和MKAnnotationView+WebCache，方便使用。 SDWebImagePrefetcher 可以预先下载图片，方便后续使用。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC机制如何通过key找到value]]></title>
    <url>%2F2017%2F11%2F28%2FKVC%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87key%E6%89%BE%E5%88%B0value%2F</url>
    <content type="text"><![CDATA[setValue:forKey: 首先搜索setKey:方法。（key指成员变量名，首字母大写） 上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key, _isKey, key, iskey的顺序搜索成员名。（NSKeyValueCodingCatogery中实现的类方法，默认实现为返回YES） 如果没有找到成员变量，调用setValue:forUnderfinedKey: valueForKey: 首先按getKey，key，isKey的顺序查找getter方法，找到直接调用。如果是BOOL、int等内建值类型，会做NSNumber的转换。 上面的getter没找到，查找countOfKey、objectInKeyAtindex、KeyAtindexes格式的方法。如果countOfKey和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。 还没找到，查找countOfKey、enumeratorOfKey、memberOfKey格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。 还是没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。 再没找到，调用valueForUndefinedKey。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block本质是什么]]></title>
    <url>%2F2017%2F11%2F25%2Fblock%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[底层实现 block是一个指针结构体，在终端下通过clang -rewrite-objc 指令查看C++代码。首先创建一个OS X 工程，写一个最简单的block利用终端编译生成C++代码clang -rewrite-objc main.m 其中几个重要的结构体和函数简介：__block_impl：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;__main_block_impl_0: 可以理解为block变量;__main_block_func_0: 可以理解为匿名函数;__main_block_desc_0:block的描述, Block_size; 1、__block_impl1struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; 2、__main_block_impl_01struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 3、__main_block_func_01static void __main_block_func_0 (struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gc_ 5fkhcz0n6px48vzc744hmp6c0000gn_T_main_eef954_mi_0); 4、__main_block_desc_01static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123;/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; void (*myblock)() = ((void (*) ())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *)) ((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock); &#125; return 0;&#125; 注意事项 block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用在MRC下用_block，在ARC下使用__weak; 关于Block在内存中的位置 block块的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区，因此ARC下只有两个地方：代码区和堆区）。 代码区： 不访问栈区的变量（如局部变量），且不访问堆区的变量（如用alloc创建的对象）时，此时block存放在代码区； 堆区： 如果访问了堆区的变量（如局部变量），或堆区的变量（如用alloc创建的对象），此时block存方在堆区；需要注意 栈区： 在ARC情况下自动拷贝到堆区，如果不是ARC则存放在栈区，所在函数执行完毕就回释放，想再外面调用需要用copy指向它，这样就拷贝到了堆区，strong属性不会拷贝、会造成野指针错区。（需要理解ARC是一种编译器特性，即编译器在编译时在核实的地方插入retain、release、autorelease，而不是iOS的运行时特性）。 block块代码存在堆区时,需要注意，因为堆区不像代码区不变化，堆区是动态的（不断的创建销毁），当没有强指针指向的时候就会被销毁，如果再去访问这段代码时，程序就会崩溃！所以此种情况在定义block属性时需要指定为strong or copy。block是一段代码，即不可变，所以使用copy也不会深拷贝。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 TableView 滑动卡顿]]></title>
    <url>%2F2017%2F11%2F23%2F%E8%A7%A3%E5%86%B3-TableView-%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[1. 最常用的就是cell的重用， 注册重用标识符 如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell 如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID 每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell 2. 避免cell的重新布局 cell的布局填充等操作 比较耗时，一般创建时就布局好可以将cell单独放到一个自定义类，在初始化时就布局好 3. 提前计算并缓存cell的属性及内容 当我们创建cell的数据源方法时，编译器并不是先创建cell 再确定cell的高度而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell 4. 减少cell中控件的数量 尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，不使用的可以先隐藏 5. 不要使用ClearColor，无背景色，透明度也不要设置为0 因为这样渲染耗时比较长 6. 使用局部更新 如果只是更新某组的话，使用reloadSection进行局部更新 7. 加载网络数据，下载图片，使用异步加载，并对图片进行缓存 8. 尽量避免addView 给cell动态添加view 避免过多的消耗性能 9. 按需加载cell，cell滚动很快时，只加载范围内的cell 10. 不要实现无用的代理方法，tableView只遵守两个协议 11. 缓存行高 estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可 小结 有了上面的方法，我们在优化tableView的时候就能很好解决卡顿的问题了。在iOS应用中，UITableView应该是使用率最高的视图之一了。iPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、Safari、App Store、iTunes、Game Center…几乎所有自带的应用中都能看到它的身影，可见它的重要性。然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看 LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>TableView</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何分析App内存]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90App%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[Xcode下查看app内存使用情况有2种方法： Navigator导航栏中的Debug navigator中的Memory Instruments 1. Debug navigator中的Memory此方法是查看内存最简单直接有效的方法，真机调试时，通过Debug navigator中Memory查看app内存，入口如图 根据这个值查看app内存占用，这个内存是当前app占用的总内存，是堆栈内存、虚拟内存（OpenGL占用的显存算在虚拟内存中里面）的总和。 2. Instruments启动Instruments的方法是，Product-&gt;Profile，经过漫长的编译时间后，出现Instruments界面，如下图 Instruments中，可以分析内存的工具有Activity Monitor、Allocations、Leaks。 LeaksLeaks是检测内存泄露的工具，很有用。Leaks运行中，看到下面这个红叉叉就表示有内存泄露了 AllocationsAllocations是检测堆栈内存的，下面的VM tracker检测虚拟内存。Allocations运行起来如下图 Allocations永远比Debug navigator Memory中显示的内存要小，就是因为Allocations中没有统计虚拟内存。下图参考： 部分malloc出来的内存也算在虚拟内存中，下图参考自A look at how malloc works on the Mac Activity monitorActivity monitor看手机整体内存情况的，这里的显示app内存值和Debug navigator中的Memory显示的值是一样的 其他 App最多能占用多少内存不闪退 占用机器内存的一半左右就会闪退，和系统版本、后台程序数有关。 不同渠道对内存有不同的要求，例如如下某渠道 iOS的App为什么内存没有泄露，内存却降不下来 eg: 创建大概20个哥布林spine动画，此时内存占用46M，然后释放掉，内存占用竟然还是46M，以为是spine有内存泄露，Leaks检测没有发现内存泄露。反复加载释放20个哥布林，内存都没有超过48M，但是为毛内存没有下降，而是维持在46M左右 因为（1）图片加入了TextureCache，占用了部分内存（2）malloc出来的一部分内存算到了VM（虚拟内存）中，为了下次malloc速度更快，这部分内存虽然调用了free，但iOS系统依然没有将其回收。这就是上面说的部分malloc出来的内存也算在虚拟内存中。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内存</tag>
        <tag>Xcode</tag>
        <tag>Instruments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存的几大区域]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%86%85%E5%AD%98%E7%9A%84%E5%87%A0%E5%A4%A7%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 栈区(stack) 栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］ 栈空间分静态分配 和动态分配两种。 静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloca函数完成。栈的动态分配无需释放(是自动的)，也就没有释放函数。为可移植的程序起见，栈的动态分配操作是不被鼓励的。 2. 堆区(heap) 堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。 优点是灵活方便，数据适应面广泛，但是效率有一定降低。 堆是函数库内部数据结构，不一定唯一。不同堆分配的内存无法互相操作。堆的分配总是动态的。 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。 3. 全局区(静态区) (static) 全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。 注意：全局区又可分为未初始化全局区(bss段)和初始化全局区(data段) 举例: int a; 未初始化的 int a = 10; 初始化的 4. 文字常量区 文字常量区 存放常量字符串，程序结束后由系统释放； 5. 代码区 代码区 存放函数的二进制代码 例子代码： 可能被追问的问题一： 栈区 (stack [stæk]):由编译器自动分配释放局部变量是保存在栈区的方法调用的实参也是保存在栈区的 堆区 (heap [hiːp]):由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！ BSS 段 :程序结束后由系统释放 数据段 :程序结束后由系统释放 代码段:程序结束后由系统释放程序编译链接 后的二进制可执行代码 可能被追问的问题二： 申请后的系统是如何响应的？ 栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。 注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：1.首先应该知道操作系统有一个记录空闲内存地址的链表。2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 可能被追问的问题三： 申请大小的限制是怎样的？ 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 栈： 由系统自动分配，速度较快，不会产生内存碎片 堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便 打个比喻来说： 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内存</tag>
      </tags>
  </entry>
</search>
