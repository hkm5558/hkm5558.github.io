{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"34af278ad7b87824b7790c79d9f56c5f9e498d47","modified":1511850987000},{"_id":"themes/next/.DS_Store","hash":"0907c08250c0612fdbe8f04ae1e7b3c2ec54d085","modified":1512194965000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1510888880000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1510888880000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1510888880000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1510888880000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1510888880000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1510888880000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1510888880000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1510888880000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1510888880000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1510888880000},{"_id":"themes/next/_config.yml","hash":"064259f0447bdcd31a241ccb1064b1d05f99656c","modified":1512194830000},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1510888880000},{"_id":"themes/next/README.cn.md","hash":"02713071ef9e260b3fe77f4403942189d55a00e9","modified":1510888880000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1510888880000},{"_id":"themes/next/README.md","hash":"529d53dfa97678f8ce4c95620b26e61154162a29","modified":1510888880000},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1510888881000},{"_id":"source/_posts/.DS_Store","hash":"d29665513ba613e6af681cbefa9f5f7784c688d9","modified":1512034192000},{"_id":"source/_posts/KVC机制如何通过key找到value.md","hash":"94f5f1d71ac75549dcc30e32025b051e91890b98","modified":1511867216000},{"_id":"source/_posts/SDWebImage基本原理.md","hash":"660568fde1a94fe5203383a4656550aa41d63939","modified":1511922307000},{"_id":"source/_posts/block本质是什么.md","hash":"5a2ecf800412dc3ba3656154ac42e81a7709b036","modified":1511864941000},{"_id":"source/_posts/Swift中enum、struct、class三者异同.md","hash":"a962382135a82489dbd56b519f14903158a20e49","modified":1512005862000},{"_id":"source/_posts/内存的几大区域.md","hash":"b1e108d0bd5b14c12016a628b945130696acc94b","modified":1511850882000},{"_id":"source/_posts/如何分析App内存.md","hash":"4dba8596c121455ace4ec9c349c1703f8f3ee02b","modified":1511864068000},{"_id":"source/_posts/解决-TableView-滑动卡顿.md","hash":"e19147330cbb1942ad00dd1fd186b38a3e42c2d0","modified":1511864111000},{"_id":"source/categories/index.md","hash":"702eef3dfb3bceb03203bb6cd1fc90d549b74994","modified":1510996756000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1510996662000},{"_id":"source/images/avatar.jpeg","hash":"4f386c7451b4e0a6f9194a9982244eb04e697dc7","modified":1510996245000},{"_id":"source/tags/index.md","hash":"1ece192e84c577ec84fbffa9d1105ae82ae0dd70","modified":1511850797000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1510888880000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1510888880000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1510888880000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1510888880000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1510888880000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1510888881000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1510888881000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1510888881000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1510888881000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1510888881000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1510888881000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1510888881000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1510888881000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1510888881000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1510888881000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1510888881000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1510888881000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1510888881000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1510888881000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1511856854000},{"_id":"themes/next/layout/.DS_Store","hash":"db26db226b8e4932dbe28a6458d61e5b80173b11","modified":1512187048000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1510888881000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1510888881000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1510888881000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1510888881000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1510888881000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1510888881000},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1510888881000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1510888881000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1510888881000},{"_id":"themes/next/source/.DS_Store","hash":"497a22c1b44426182974566cd0d9e7ebb9602fd7","modified":1511853151000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1510888881000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1510888881000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1510888881000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"source/_posts/block本质是什么/pic1.jpeg","hash":"cccf097e6ab50fbd7757f8d5937664220f4cf402","modified":1511862177000},{"_id":"source/_posts/内存的几大区域/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1510914615000},{"_id":"source/_posts/内存的几大区域/pic2.jpg","hash":"c89d239d1288ac3b3f34a1f7082b61134603e854","modified":1510913102000},{"_id":"source/_posts/内存的几大区域/pic3.jpg","hash":"0ba4f9b649d755cb01353ac5a4d3946482c2c5a7","modified":1510913111000},{"_id":"source/_posts/内存的几大区域/pic4.png","hash":"7fbd81e38da709012bdc19d1a54aeea203a809d1","modified":1510913123000},{"_id":"source/_posts/如何分析App内存/pic1.jpeg","hash":"0644ab9ee11a9cd337bdfe934af8dcb74e412ad9","modified":1511858488000},{"_id":"source/_posts/如何分析App内存/pic10.jpeg","hash":"94050d4a0988ef224027906a3f2db0fd2195f682","modified":1511860050000},{"_id":"source/_posts/如何分析App内存/pic3.jpeg","hash":"22b5dd3e4c9c543e79569b5f9413221720769cce","modified":1511859345000},{"_id":"source/_posts/如何分析App内存/pic5.jpeg","hash":"e618ee323d081bcdf308b4fe8a318764ed62f316","modified":1511859579000},{"_id":"source/_posts/如何分析App内存/pic2.jpeg","hash":"c40e5c4075248f4339314d744a7925f214bc8a6d","modified":1511859224000},{"_id":"source/_posts/如何分析App内存/pic4.jpeg","hash":"a9076bf80e6887694f52b8ab75862a0e8d58034b","modified":1511859514000},{"_id":"source/_posts/如何分析App内存/pic7.jpeg","hash":"01741d3c6f7a1c00d482d21f9c5b65ebced568d1","modified":1511859710000},{"_id":"source/_posts/如何分析App内存/pic6.jpeg","hash":"d16f87861284d2248469ae6163d0d02cab4778f8","modified":1511859595000},{"_id":"source/_posts/如何分析App内存/pic9.jpeg","hash":"e9e890b14fe667dcc4699b42cc20b4ce876daf87","modified":1511859939000},{"_id":"source/_posts/如何分析App内存/pic8.jpeg","hash":"96c8a8786ff65484675e7f5626eeefe6a06389cc","modified":1511859898000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1511857013000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"29d1a3d3bfd0c847a95221aa4022afa191befe4f","modified":1511857053000},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"da03a52db285dfd2b6cc6ffaeb1a23c20bca8205","modified":1510992973000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1510888881000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1510888881000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1510888881000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f1b2187295483e660186f206b0d576de641bf9f5","modified":1511849823000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"e533462543416365c50fc46b4733c653544402b3","modified":1511856705000},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"ac37a342cd76e1cbf8a9794d8d235f01f6298ca0","modified":1510989063000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1510888881000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1510888881000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d9aac404b1ee8c4eaf8e62b5ed6067b00f3bb77d","modified":1511834129000},{"_id":"themes/next/layout/_partials/head.swig","hash":"5303183a8ef34f29e04b8f127ba1c9283e8c2699","modified":1512195185000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1510888881000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1510888881000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1510888881000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1510888881000},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"499d9587043d09cd6ba79b01f972a0a284b0c9f3","modified":1512187054000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1510888881000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1510888881000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1510888881000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1510888881000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1510888881000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1510888881000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1510888881000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1510888881000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1510888881000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1510888881000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1510888881000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1510888881000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1510888881000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1510888881000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1510888881000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1510888881000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1510888881000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1510888881000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1510888881000},{"_id":"themes/next/source/css/.DS_Store","hash":"d64b0d6d3fd55e908a6046e77bb6ca0179f36079","modified":1511854288000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1510888881000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1510888881000},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1511852913000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1510888881000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1510888881000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1510888881000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1510888881000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1510888881000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1510888881000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1510888881000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1510888881000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510888881000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1510888881000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"b472a8c061a7867352dee10e2a3d8480881bd0c0","modified":1511852773000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510888881000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1510888881000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"6b8ca830f4a1ac33fb787e9c8b47bbd437b4de28","modified":1511852845000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1510888881000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1510888881000},{"_id":"source/_posts/内存的几大区域/pic1.jpg","hash":"e11e59118c9db6ee2bb49d94fd8e79916c6355bd","modified":1510913092000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510888881000},{"_id":"themes/next/source/images/avatar.png","hash":"1458197e22f889b2c8d039200e73c9256f459f9e","modified":1510889481000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1510888881000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1510888881000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1510888881000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1510888881000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1510888881000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1510888881000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1510888881000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1510888881000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1510888881000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1510888881000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1510888881000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1510888881000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1510888881000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1510888881000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1510888881000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1510888881000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1510888881000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1510888881000},{"_id":"themes/next/source/css/_common/.DS_Store","hash":"c08e3427b7cae126fe16eeaf7e3d3d3be6e96e08","modified":1510890396000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"921183081e8857bb1773f8d7722bf1352b9e1f4d","modified":1511834293000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1510888881000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1510888881000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"94729f543651f6ff5e011ad6d6561bac23862e1a","modified":1511854374000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1510888881000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1510888881000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1510888881000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"80a543307f4364d282bf8258e36056374fb89cb1","modified":1511854142000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1510888881000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1510888881000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1510888881000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1510888881000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1510888881000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1510888881000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1510888881000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1510888881000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1510888881000},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1510888881000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1510888881000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1510888881000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1510888881000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1510888881000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1510888881000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1510888881000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1510888881000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1510888881000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1510888881000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1510888881000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1510888881000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1510888881000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1510888881000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1510888881000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1510888881000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1510888881000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1510888881000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1510888881000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1510888881000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1510888881000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1510888881000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1510888881000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1510888881000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1510888881000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1510888881000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1510888881000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1510888881000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1510888881000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1510888881000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/.DS_Store","hash":"993cc04e2cd6c2733eaba0128aa122abde87498d","modified":1510995356000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1510888881000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1510888881000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1510888881000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1510888881000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1510888881000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1510888881000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1510888881000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1510888881000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1510888881000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1510888881000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1510888881000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1510888881000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1510888881000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"befc501bf1f95c50dfc0fb99418e03094368bc94","modified":1510996072000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1510888881000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1510888881000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1510888881000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1510888881000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1510888881000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1510888881000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1510888881000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1510888881000},{"_id":"public/categories/index.html","hash":"979b678c431667a23125f5b3f66b33f9551dfbba","modified":1512195197446},{"_id":"public/tags/index.html","hash":"e87af3ae5a8d1bc089e1c0e723a011441f0e3cab","modified":1512195197446},{"_id":"public/categories/Swift/index.html","hash":"c62317bed23747538c188e0ad0e605546200b551","modified":1512195197446},{"_id":"public/tags/KVC/index.html","hash":"73de8e6a868d80d19246cc92625f984c64ce11a7","modified":1512195197447},{"_id":"public/tags/SDWebImage/index.html","hash":"05bbe27f3dd013c184ed5a75654c86cf173c3dc9","modified":1512195197447},{"_id":"public/tags/Block/index.html","hash":"b23e889b0c6d830d343f66f1407c3c9826979b75","modified":1512195197447},{"_id":"public/tags/Swift/index.html","hash":"2983ef5bcd6ff6ee7ae142d4dbce01239f347125","modified":1512195197447},{"_id":"public/tags/Class/index.html","hash":"e64808e6c7d742bde3eed2a6d18b4f7f1796c147","modified":1512195197447},{"_id":"public/tags/Enum/index.html","hash":"7ca9f6140401fd0fd82257c9dc9dceb5d0e0e6ef","modified":1512195197447},{"_id":"public/tags/Struct/index.html","hash":"cea17923245684af5f791293def020b948bfd922","modified":1512195197447},{"_id":"public/tags/内存/index.html","hash":"6dd3a3e38ea324977927c2cb7e18ddb939f1b60b","modified":1512195197447},{"_id":"public/tags/Xcode/index.html","hash":"5675f35902c1e3be5915d3cdab56bd65a0a26f5c","modified":1512195197447},{"_id":"public/tags/Instruments/index.html","hash":"a0f4c7d8a988f4f651fdadc4a741510d809aa5a7","modified":1512195197447},{"_id":"public/tags/TableView/index.html","hash":"37f455b9c9be45b1599eb4b0f8429ab8c6e9ce83","modified":1512195197447},{"_id":"public/tags/优化/index.html","hash":"aac0cabb558fb7585ddf1792fbd5b053ea5d446c","modified":1512195197447},{"_id":"public/2017/11/29/Swift中enum、struct、class三者异同/index.html","hash":"7b06a24b0b8d60eb5ebf259ddd847c8ec0295119","modified":1512195197447},{"_id":"public/2017/11/29/SDWebImage基本原理/index.html","hash":"b7de886d1d74df470a6d092ceb7f05b8f2b9311c","modified":1512195197447},{"_id":"public/2017/11/28/KVC机制如何通过key找到value/index.html","hash":"cc8f286f405f04fd948badc4342abec9be78fba4","modified":1512195197447},{"_id":"public/2017/11/25/block本质是什么/index.html","hash":"c49bfc7fe34e0cf5e588aa3a9e7c2eb62900f768","modified":1512195197447},{"_id":"public/2017/11/23/解决-TableView-滑动卡顿/index.html","hash":"6d6d2f32d52a9fcb9049ebaccfe6dc306bdc034c","modified":1512195197447},{"_id":"public/2017/11/18/如何分析App内存/index.html","hash":"14ef862faf609372d75936a76a966db1bbeb852a","modified":1512195197448},{"_id":"public/2017/11/17/内存的几大区域/index.html","hash":"4b2344a99b8cdfe4bd84f338c6774694ec5c3de2","modified":1512195197448},{"_id":"public/archives/index.html","hash":"9b0d0772302341fab1f46724bf6dc587420f4e9c","modified":1512195197448},{"_id":"public/archives/2017/index.html","hash":"b4174b15257b3cefada4509701281fc994c481af","modified":1512195197448},{"_id":"public/archives/2017/11/index.html","hash":"b0458180499fe9bff085978ec8b3d6a607555d29","modified":1512195197448},{"_id":"public/categories/Question/index.html","hash":"89fc17e437eca9e4ed6017cb008b129c5c661ef6","modified":1512195197448},{"_id":"public/index.html","hash":"4b423982d79083de371f530af9bb3c611a0cfab0","modified":1512195197448},{"_id":"public/tags/iOS/index.html","hash":"78d7d7d6497029e527b6b8d2f9b9b6851a11ff3c","modified":1512195197448},{"_id":"public/images/avatar.jpeg","hash":"4f386c7451b4e0a6f9194a9982244eb04e697dc7","modified":1512195197456},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1512195197456},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1512195197456},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1512195197456},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1512195197456},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1512195197456},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1512195197456},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1512195197456},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1512195197456},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1512195197456},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512195197457},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1512195197457},{"_id":"public/images/favicon-32x32-next.png","hash":"b472a8c061a7867352dee10e2a3d8480881bd0c0","modified":1512195197457},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512195197457},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1512195197457},{"_id":"public/images/favicon-16x16-next.png","hash":"6b8ca830f4a1ac33fb787e9c8b47bbd437b4de28","modified":1512195197457},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1512195197457},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1512195197457},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1512195197457},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1512195197457},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1512195197457},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1512195197457},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1512195197457},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1512195197457},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1512195197457},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1512195197457},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1512195197457},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1512195197457},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1512195197458},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1512195197458},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1512195197458},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1512195197458},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1512195197458},{"_id":"public/2017/11/25/block本质是什么/pic1.jpeg","hash":"cccf097e6ab50fbd7757f8d5937664220f4cf402","modified":1512195197458},{"_id":"public/2017/11/17/内存的几大区域/pic3.jpg","hash":"0ba4f9b649d755cb01353ac5a4d3946482c2c5a7","modified":1512195197458},{"_id":"public/2017/11/17/内存的几大区域/pic2.jpg","hash":"c89d239d1288ac3b3f34a1f7082b61134603e854","modified":1512195197458},{"_id":"public/2017/11/17/内存的几大区域/pic4.png","hash":"7fbd81e38da709012bdc19d1a54aeea203a809d1","modified":1512195197458},{"_id":"public/2017/11/18/如何分析App内存/pic1.jpeg","hash":"0644ab9ee11a9cd337bdfe934af8dcb74e412ad9","modified":1512195197458},{"_id":"public/2017/11/18/如何分析App内存/pic10.jpeg","hash":"94050d4a0988ef224027906a3f2db0fd2195f682","modified":1512195197458},{"_id":"public/2017/11/18/如何分析App内存/pic3.jpeg","hash":"22b5dd3e4c9c543e79569b5f9413221720769cce","modified":1512195197458},{"_id":"public/2017/11/18/如何分析App内存/pic2.jpeg","hash":"c40e5c4075248f4339314d744a7925f214bc8a6d","modified":1512195197458},{"_id":"public/2017/11/18/如何分析App内存/pic4.jpeg","hash":"a9076bf80e6887694f52b8ab75862a0e8d58034b","modified":1512195197458},{"_id":"public/2017/11/18/如何分析App内存/pic5.jpeg","hash":"e618ee323d081bcdf308b4fe8a318764ed62f316","modified":1512195197459},{"_id":"public/2017/11/18/如何分析App内存/pic6.jpeg","hash":"d16f87861284d2248469ae6163d0d02cab4778f8","modified":1512195197459},{"_id":"public/2017/11/18/如何分析App内存/pic7.jpeg","hash":"01741d3c6f7a1c00d482d21f9c5b65ebced568d1","modified":1512195197459},{"_id":"public/2017/11/18/如何分析App内存/pic8.jpeg","hash":"96c8a8786ff65484675e7f5626eeefe6a06389cc","modified":1512195197459},{"_id":"public/2017/11/18/如何分析App内存/pic9.jpeg","hash":"e9e890b14fe667dcc4699b42cc20b4ce876daf87","modified":1512195197459},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"9d1b45b47c0bc926e1c541f35225cffb1ce0048d","modified":1512195197459},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"de560936d3b893014b12dc0f87d74c5e59545b51","modified":1512195197459},{"_id":"public/images/avatar.png","hash":"1458197e22f889b2c8d039200e73c9256f459f9e","modified":1512195198075},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1512195198077},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1512195198096},{"_id":"public/2017/11/17/内存的几大区域/pic1.jpg","hash":"e11e59118c9db6ee2bb49d94fd8e79916c6355bd","modified":1512195198097},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"2dd468bd234fbb9553508a0bd30643bb1a63cccc","modified":1512195198098},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1512195198105},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1512195198105},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1512195198105},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1512195198105},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1512195198105},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1512195198105},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1512195198105},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1512195198105},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1512195198105},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1512195198106},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1512195198106},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1512195198106},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1512195198106},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1512195198106},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1512195198106},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1512195198106},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1512195198106},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1512195198106},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1512195198106},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1512195198106},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1512195198106},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1512195198106},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1512195198106},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1512195198106},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1512195198106},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1512195198106},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1512195198106},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1512195198107},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1512195198107},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1512195198107},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1512195198107},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1512195198107},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1512195198107},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1512195198107},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1512195198107},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1512195198107},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1512195198107},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1512195198108},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1512195198108},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1512195198108},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1512195198108},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1512195198108},{"_id":"public/css/main.css","hash":"9efbada32068ca734567b3a4063a27cdf1fb8a6c","modified":1512195198108},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1512195198108},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1512195198108},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1512195198108},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1512195198108},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1512195198108},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1512195198108},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1512195198108},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1512195198108},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1512195198108},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1512195198108},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1512195198108},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1512195198109},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1512195198109},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1512195198109},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1512195198109},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1512195198109},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1512195198109},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1512195198109},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1512195198109},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1512195198109},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1512195198109},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1512195198110},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1512195198110},{"_id":"public/assets/algolia/algoliasearch.js","hash":"750c3ec801fad23cf295df7cc5d5370cb42dd29a","modified":1512195198110},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1512195198132}],"Category":[{"name":"Question","_id":"cjaoxz43d0004sku27m8sh4a0"},{"name":"Swift","_id":"cjaoxz43r000isku280bo23jp"}],"Data":[],"Page":[{"title":"categories","date":"2017-11-18T09:18:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-11-18 17:18:43\ntype: \"categories\"\n---\n","updated":"2017-11-18T09:19:16.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjaoxz4390001sku2w78dz63f","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-11-28T06:23:32.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-11-28 14:23:32\ntype: tags\n---\n","updated":"2017-11-28T06:33:17.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjaoxz43b0003sku27wp8d432","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"KVC机制如何通过key找到value","date":"2017-11-28T11:02:54.000Z","_content":"\n- **setValue:forKey**:\n\n\n\n> 1.  \n首先搜索`setKey:`方法。  \n（key指成员变量名，首字母大写）  \n2.   \n上面的setter方法没找到, 如果类方法`accessInstanceVariablesDirectly`返回`YES`。  \n那么按 `_key`, `_isKey`, `key`, iskey的顺序搜索成员名。（`NSKeyValueCodingCatogery`中实现的类方法，默认实现为返回`YES`）  \n3.   \n如果没有找到成员变量，调用`setValue:forUnderfinedKey:`\n\n- **valueForKey**:\n\n> 1. \n首先按`getKey`，`key`，`isKey`的顺序查找getter方法，找到直接调用。如果是`BOOL`、`int`等内建值类型，会做`NSNumber`的转换。  \n2.  \n上面的getter没找到，查找`countOfKey`、`objectInKeyAtindex、KeyAtindexes`格式的方法。如`果countOfKey`和另外两个方法中的一个找到，那么就会返回一个可以响应`NSArray`所有方法的代理集合的`NSArray`消息方法。  \n3.  \n还没找到，查找`countOfKey`、`enumeratorOfKey`、`memberOfKey`格式的方法。如果这三个方法都找到，那么就返回一个可以响应`NSSet`所有方法的代理集合。  \n4.  \n还是没找到，如果类方法`accessInstanceVariablesDirectly`返回`YES`。那么按 `_key`，`_isKey`，`key`，`iskey`的顺序搜索成员名。    \n5.  \n再没找到，调用`valueForUndefinedKey`。  \n\n","source":"_posts/KVC机制如何通过key找到value.md","raw":"---\ntitle: KVC机制如何通过key找到value\ndate: 2017-11-28 19:02:54\ntags: [iOS, KVC]\ncategories: Question\n---\n\n- **setValue:forKey**:\n\n\n\n> 1.  \n首先搜索`setKey:`方法。  \n（key指成员变量名，首字母大写）  \n2.   \n上面的setter方法没找到, 如果类方法`accessInstanceVariablesDirectly`返回`YES`。  \n那么按 `_key`, `_isKey`, `key`, iskey的顺序搜索成员名。（`NSKeyValueCodingCatogery`中实现的类方法，默认实现为返回`YES`）  \n3.   \n如果没有找到成员变量，调用`setValue:forUnderfinedKey:`\n\n- **valueForKey**:\n\n> 1. \n首先按`getKey`，`key`，`isKey`的顺序查找getter方法，找到直接调用。如果是`BOOL`、`int`等内建值类型，会做`NSNumber`的转换。  \n2.  \n上面的getter没找到，查找`countOfKey`、`objectInKeyAtindex、KeyAtindexes`格式的方法。如`果countOfKey`和另外两个方法中的一个找到，那么就会返回一个可以响应`NSArray`所有方法的代理集合的`NSArray`消息方法。  \n3.  \n还没找到，查找`countOfKey`、`enumeratorOfKey`、`memberOfKey`格式的方法。如果这三个方法都找到，那么就返回一个可以响应`NSSet`所有方法的代理集合。  \n4.  \n还是没找到，如果类方法`accessInstanceVariablesDirectly`返回`YES`。那么按 `_key`，`_isKey`，`key`，`iskey`的顺序搜索成员名。    \n5.  \n再没找到，调用`valueForUndefinedKey`。  \n\n","slug":"KVC机制如何通过key找到value","published":1,"updated":"2017-11-28T11:06:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz4350000sku2aq0t9sq3","content":"<ul>\n<li><strong>setValue:forKey</strong>:</li>\n</ul>\n<blockquote>\n<ol>\n<li>首先搜索<code>setKey:</code>方法。<br>（key指成员变量名，首字母大写）  </li>\n<li>上面的setter方法没找到, 如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>。<br>那么按 <code>_key</code>, <code>_isKey</code>, <code>key</code>, iskey的顺序搜索成员名。（<code>NSKeyValueCodingCatogery</code>中实现的类方法，默认实现为返回<code>YES</code>）  </li>\n<li>如果没有找到成员变量，调用<code>setValue:forUnderfinedKey:</code></li>\n</ol>\n</blockquote>\n<ul>\n<li><strong>valueForKey</strong>:</li>\n</ul>\n<blockquote>\n<ol>\n<li>首先按<code>getKey</code>，<code>key</code>，<code>isKey</code>的顺序查找getter方法，找到直接调用。如果是<code>BOOL</code>、<code>int</code>等内建值类型，会做<code>NSNumber</code>的转换。  </li>\n<li>上面的getter没找到，查找<code>countOfKey</code>、<code>objectInKeyAtindex、KeyAtindexes</code>格式的方法。如<code>果countOfKey</code>和另外两个方法中的一个找到，那么就会返回一个可以响应<code>NSArray</code>所有方法的代理集合的<code>NSArray</code>消息方法。  </li>\n<li>还没找到，查找<code>countOfKey</code>、<code>enumeratorOfKey</code>、<code>memberOfKey</code>格式的方法。如果这三个方法都找到，那么就返回一个可以响应<code>NSSet</code>所有方法的代理集合。  </li>\n<li>还是没找到，如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>。那么按 <code>_key</code>，<code>_isKey</code>，<code>key</code>，<code>iskey</code>的顺序搜索成员名。    </li>\n<li>再没找到，调用<code>valueForUndefinedKey</code>。  </li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><strong>setValue:forKey</strong>:</li>\n</ul>\n<blockquote>\n<ol>\n<li>首先搜索<code>setKey:</code>方法。<br>（key指成员变量名，首字母大写）  </li>\n<li>上面的setter方法没找到, 如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>。<br>那么按 <code>_key</code>, <code>_isKey</code>, <code>key</code>, iskey的顺序搜索成员名。（<code>NSKeyValueCodingCatogery</code>中实现的类方法，默认实现为返回<code>YES</code>）  </li>\n<li>如果没有找到成员变量，调用<code>setValue:forUnderfinedKey:</code></li>\n</ol>\n</blockquote>\n<ul>\n<li><strong>valueForKey</strong>:</li>\n</ul>\n<blockquote>\n<ol>\n<li>首先按<code>getKey</code>，<code>key</code>，<code>isKey</code>的顺序查找getter方法，找到直接调用。如果是<code>BOOL</code>、<code>int</code>等内建值类型，会做<code>NSNumber</code>的转换。  </li>\n<li>上面的getter没找到，查找<code>countOfKey</code>、<code>objectInKeyAtindex、KeyAtindexes</code>格式的方法。如<code>果countOfKey</code>和另外两个方法中的一个找到，那么就会返回一个可以响应<code>NSArray</code>所有方法的代理集合的<code>NSArray</code>消息方法。  </li>\n<li>还没找到，查找<code>countOfKey</code>、<code>enumeratorOfKey</code>、<code>memberOfKey</code>格式的方法。如果这三个方法都找到，那么就返回一个可以响应<code>NSSet</code>所有方法的代理集合。  </li>\n<li>还是没找到，如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>。那么按 <code>_key</code>，<code>_isKey</code>，<code>key</code>，<code>iskey</code>的顺序搜索成员名。    </li>\n<li>再没找到，调用<code>valueForUndefinedKey</code>。  </li>\n</ol>\n</blockquote>\n"},{"title":"SDWebImage基本原理","date":"2017-11-29T01:52:08.000Z","_content":"\n\n1. 入口 `setImageWithURL:placeholderImage:options:`\n---\n\n> 会先把 `placeholderImage` 显示，然后 `SDWebImageManager` 根据 URL 开始处理图片。  \n\n2. 进入 `SDWebImageManagerdownloadWithURL:delegate:options:userInfo:`\n---\n\n> 交给 `SDImageCache` 从缓存查找图片是否已经下载  \n`queryDiskCacheForKey:delegate:userInfo:`\n\n3. 先从内存图片缓存查找是否有图片\n---\n\n> 如果内存中已经有图片缓存，`SDImageCacheDelegate` 回调 `imageCache:didFindImage:forKey:userInfo:` 到 `SDWebImageManager`，`SDWebImageManagerDelegate `回调 `webImageManager:didFinishWithImage:`到 `UIImageView+WebCache` 等前端展示图片\n\n4. 如果内存缓存中没有\n---\n\n> 生成 `NSInvocationOperation`\n添加到队列开始从硬盘查找图片是否已经缓存  \n\n5. 根据 `URLKey` 在硬盘缓存目录下尝试读取图片文件\n---\n\n> 这一步是在 `NSOperation` 进行的操作，所以回主线程进行结果回调 `notifyDelegate:`\n\n6. 如果从硬盘读取到了图片\n---\n\n> 将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存），`SDImageCacheDelegate` 回调 `imageCache:didFindImage:forKey:userInfo:`。\n进而回调展示图片\n\n7. 如果从硬盘缓存目录读取不到图片\n---\n\n> 说明所有缓存都不存在该图片，需要下载图片，\n回调 `imageCache:didNotFindImageForKey:userInfo:`\n\n8. 下载图片\n---\n\n> 共享或重新生成一个下载器 `SDWebImageDownloader` 开始下载图片。图片下载由 `NSURLConnection` 来做，\n实现相关 `delegate` 来判断图片下载中、下载完成和下载失败。  \n`connection:didReceiveData:` 中  \n利用 `ImageIO` 做了按图片下载进度加载效果\n\n9. 数据下载完成\n---\n\n> `connectionDidFinishLoading:` 数据下载完成后交给 `SDWebImageDecoder` 做图片解码处理\n\n10. 图片解码\n---\n\n> 图片解码处理在一个 NSOperationQueue 完成，\n不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，\n最好也在这里完成，效率会好很多。\n\n11. 解码完成\n---\n\n> 在主线程 `notifyDelegateOnMainThreadWithInfo:`\n宣告解码完成，\n`imageDecoder:didFinishDecodingImage:userInfo:`\n回调给 `SDWebImageDownloader`。\n\n12. 图片下载完成\n---\n\n> `imageDownloader:didFinishWithImage:`\n回调给 `SDWebImageManager` 告知图片下载完成。\n通知所有的 `downloadDelegates` 下载完成，\n回调给需要的地方展示图片。\n\n13. 缓存图片\n---\n\n> 将图片保存到 `SDImageCache` 中，\n内存缓存和硬盘缓存同时保存。\n写文件到硬盘也在以单独 `NSInvocationOperation` 完成，\n避免拖慢主线程。\n\n14. 其他\n---\n\n> \n - `SDImageCache` 在初始化的时候会注册一些消息通知\n 在内存警告或退到后台的时候清理内存图片缓存，\n应用结束的时候清理过期图片。  \n - `SDWebImage` 也提供了 `UIButton+WebCache` 和\n`MKAnnotationView+WebCache`，方便使用。\n - `SDWebImagePrefetcher` 可以预先下载图片，\n方便后续使用。","source":"_posts/SDWebImage基本原理.md","raw":"---\ntitle: SDWebImage基本原理\ndate: 2017-11-29 09:52:08\ntags: [iOS, SDWebImage]\ncategories: Question\n---\n\n\n1. 入口 `setImageWithURL:placeholderImage:options:`\n---\n\n> 会先把 `placeholderImage` 显示，然后 `SDWebImageManager` 根据 URL 开始处理图片。  \n\n2. 进入 `SDWebImageManagerdownloadWithURL:delegate:options:userInfo:`\n---\n\n> 交给 `SDImageCache` 从缓存查找图片是否已经下载  \n`queryDiskCacheForKey:delegate:userInfo:`\n\n3. 先从内存图片缓存查找是否有图片\n---\n\n> 如果内存中已经有图片缓存，`SDImageCacheDelegate` 回调 `imageCache:didFindImage:forKey:userInfo:` 到 `SDWebImageManager`，`SDWebImageManagerDelegate `回调 `webImageManager:didFinishWithImage:`到 `UIImageView+WebCache` 等前端展示图片\n\n4. 如果内存缓存中没有\n---\n\n> 生成 `NSInvocationOperation`\n添加到队列开始从硬盘查找图片是否已经缓存  \n\n5. 根据 `URLKey` 在硬盘缓存目录下尝试读取图片文件\n---\n\n> 这一步是在 `NSOperation` 进行的操作，所以回主线程进行结果回调 `notifyDelegate:`\n\n6. 如果从硬盘读取到了图片\n---\n\n> 将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存），`SDImageCacheDelegate` 回调 `imageCache:didFindImage:forKey:userInfo:`。\n进而回调展示图片\n\n7. 如果从硬盘缓存目录读取不到图片\n---\n\n> 说明所有缓存都不存在该图片，需要下载图片，\n回调 `imageCache:didNotFindImageForKey:userInfo:`\n\n8. 下载图片\n---\n\n> 共享或重新生成一个下载器 `SDWebImageDownloader` 开始下载图片。图片下载由 `NSURLConnection` 来做，\n实现相关 `delegate` 来判断图片下载中、下载完成和下载失败。  \n`connection:didReceiveData:` 中  \n利用 `ImageIO` 做了按图片下载进度加载效果\n\n9. 数据下载完成\n---\n\n> `connectionDidFinishLoading:` 数据下载完成后交给 `SDWebImageDecoder` 做图片解码处理\n\n10. 图片解码\n---\n\n> 图片解码处理在一个 NSOperationQueue 完成，\n不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，\n最好也在这里完成，效率会好很多。\n\n11. 解码完成\n---\n\n> 在主线程 `notifyDelegateOnMainThreadWithInfo:`\n宣告解码完成，\n`imageDecoder:didFinishDecodingImage:userInfo:`\n回调给 `SDWebImageDownloader`。\n\n12. 图片下载完成\n---\n\n> `imageDownloader:didFinishWithImage:`\n回调给 `SDWebImageManager` 告知图片下载完成。\n通知所有的 `downloadDelegates` 下载完成，\n回调给需要的地方展示图片。\n\n13. 缓存图片\n---\n\n> 将图片保存到 `SDImageCache` 中，\n内存缓存和硬盘缓存同时保存。\n写文件到硬盘也在以单独 `NSInvocationOperation` 完成，\n避免拖慢主线程。\n\n14. 其他\n---\n\n> \n - `SDImageCache` 在初始化的时候会注册一些消息通知\n 在内存警告或退到后台的时候清理内存图片缓存，\n应用结束的时候清理过期图片。  \n - `SDWebImage` 也提供了 `UIButton+WebCache` 和\n`MKAnnotationView+WebCache`，方便使用。\n - `SDWebImagePrefetcher` 可以预先下载图片，\n方便后续使用。","slug":"SDWebImage基本原理","published":1,"updated":"2017-11-29T02:25:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz43a0002sku2kevm3go9","content":"<h2 id=\"1-入口-setImageWithURL-placeholderImage-options\"><a href=\"#1-入口-setImageWithURL-placeholderImage-options\" class=\"headerlink\" title=\"1. 入口 setImageWithURL:placeholderImage:options:\"></a>1. 入口 <code>setImageWithURL:placeholderImage:options:</code></h2><blockquote>\n<p>会先把 <code>placeholderImage</code> 显示，然后 <code>SDWebImageManager</code> 根据 URL 开始处理图片。  </p>\n</blockquote>\n<h2 id=\"2-进入-SDWebImageManagerdownloadWithURL-delegate-options-userInfo\"><a href=\"#2-进入-SDWebImageManagerdownloadWithURL-delegate-options-userInfo\" class=\"headerlink\" title=\"2. 进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:\"></a>2. 进入 <code>SDWebImageManagerdownloadWithURL:delegate:options:userInfo:</code></h2><blockquote>\n<p>交给 <code>SDImageCache</code> 从缓存查找图片是否已经下载<br><code>queryDiskCacheForKey:delegate:userInfo:</code></p>\n</blockquote>\n<h2 id=\"3-先从内存图片缓存查找是否有图片\"><a href=\"#3-先从内存图片缓存查找是否有图片\" class=\"headerlink\" title=\"3. 先从内存图片缓存查找是否有图片\"></a>3. 先从内存图片缓存查找是否有图片</h2><blockquote>\n<p>如果内存中已经有图片缓存，<code>SDImageCacheDelegate</code> 回调 <code>imageCache:didFindImage:forKey:userInfo:</code> 到 <code>SDWebImageManager</code>，<code>SDWebImageManagerDelegate</code>回调 <code>webImageManager:didFinishWithImage:</code>到 <code>UIImageView+WebCache</code> 等前端展示图片</p>\n</blockquote>\n<h2 id=\"4-如果内存缓存中没有\"><a href=\"#4-如果内存缓存中没有\" class=\"headerlink\" title=\"4. 如果内存缓存中没有\"></a>4. 如果内存缓存中没有</h2><blockquote>\n<p>生成 <code>NSInvocationOperation</code><br>添加到队列开始从硬盘查找图片是否已经缓存  </p>\n</blockquote>\n<h2 id=\"5-根据-URLKey-在硬盘缓存目录下尝试读取图片文件\"><a href=\"#5-根据-URLKey-在硬盘缓存目录下尝试读取图片文件\" class=\"headerlink\" title=\"5. 根据 URLKey 在硬盘缓存目录下尝试读取图片文件\"></a>5. 根据 <code>URLKey</code> 在硬盘缓存目录下尝试读取图片文件</h2><blockquote>\n<p>这一步是在 <code>NSOperation</code> 进行的操作，所以回主线程进行结果回调 <code>notifyDelegate:</code></p>\n</blockquote>\n<h2 id=\"6-如果从硬盘读取到了图片\"><a href=\"#6-如果从硬盘读取到了图片\" class=\"headerlink\" title=\"6. 如果从硬盘读取到了图片\"></a>6. 如果从硬盘读取到了图片</h2><blockquote>\n<p>将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存），<code>SDImageCacheDelegate</code> 回调 <code>imageCache:didFindImage:forKey:userInfo:</code>。<br>进而回调展示图片</p>\n</blockquote>\n<h2 id=\"7-如果从硬盘缓存目录读取不到图片\"><a href=\"#7-如果从硬盘缓存目录读取不到图片\" class=\"headerlink\" title=\"7. 如果从硬盘缓存目录读取不到图片\"></a>7. 如果从硬盘缓存目录读取不到图片</h2><blockquote>\n<p>说明所有缓存都不存在该图片，需要下载图片，<br>回调 <code>imageCache:didNotFindImageForKey:userInfo:</code></p>\n</blockquote>\n<h2 id=\"8-下载图片\"><a href=\"#8-下载图片\" class=\"headerlink\" title=\"8. 下载图片\"></a>8. 下载图片</h2><blockquote>\n<p>共享或重新生成一个下载器 <code>SDWebImageDownloader</code> 开始下载图片。图片下载由 <code>NSURLConnection</code> 来做，<br>实现相关 <code>delegate</code> 来判断图片下载中、下载完成和下载失败。<br><code>connection:didReceiveData:</code> 中<br>利用 <code>ImageIO</code> 做了按图片下载进度加载效果</p>\n</blockquote>\n<h2 id=\"9-数据下载完成\"><a href=\"#9-数据下载完成\" class=\"headerlink\" title=\"9. 数据下载完成\"></a>9. 数据下载完成</h2><blockquote>\n<p><code>connectionDidFinishLoading:</code> 数据下载完成后交给 <code>SDWebImageDecoder</code> 做图片解码处理</p>\n</blockquote>\n<h2 id=\"10-图片解码\"><a href=\"#10-图片解码\" class=\"headerlink\" title=\"10. 图片解码\"></a>10. 图片解码</h2><blockquote>\n<p>图片解码处理在一个 NSOperationQueue 完成，<br>不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，<br>最好也在这里完成，效率会好很多。</p>\n</blockquote>\n<h2 id=\"11-解码完成\"><a href=\"#11-解码完成\" class=\"headerlink\" title=\"11. 解码完成\"></a>11. 解码完成</h2><blockquote>\n<p>在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code><br>宣告解码完成，<br><code>imageDecoder:didFinishDecodingImage:userInfo:</code><br>回调给 <code>SDWebImageDownloader</code>。</p>\n</blockquote>\n<h2 id=\"12-图片下载完成\"><a href=\"#12-图片下载完成\" class=\"headerlink\" title=\"12. 图片下载完成\"></a>12. 图片下载完成</h2><blockquote>\n<p><code>imageDownloader:didFinishWithImage:</code><br>回调给 <code>SDWebImageManager</code> 告知图片下载完成。<br>通知所有的 <code>downloadDelegates</code> 下载完成，<br>回调给需要的地方展示图片。</p>\n</blockquote>\n<h2 id=\"13-缓存图片\"><a href=\"#13-缓存图片\" class=\"headerlink\" title=\"13. 缓存图片\"></a>13. 缓存图片</h2><blockquote>\n<p>将图片保存到 <code>SDImageCache</code> 中，<br>内存缓存和硬盘缓存同时保存。<br>写文件到硬盘也在以单独 <code>NSInvocationOperation</code> 完成，<br>避免拖慢主线程。</p>\n</blockquote>\n<h2 id=\"14-其他\"><a href=\"#14-其他\" class=\"headerlink\" title=\"14. 其他\"></a>14. 其他</h2><blockquote>\n<ul>\n<li><code>SDImageCache</code> 在初始化的时候会注册一些消息通知<br>在内存警告或退到后台的时候清理内存图片缓存，<br>应用结束的时候清理过期图片。  </li>\n<li><code>SDWebImage</code> 也提供了 <code>UIButton+WebCache</code> 和<br><code>MKAnnotationView+WebCache</code>，方便使用。</li>\n<li><code>SDWebImagePrefetcher</code> 可以预先下载图片，<br>方便后续使用。</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-入口-setImageWithURL-placeholderImage-options\"><a href=\"#1-入口-setImageWithURL-placeholderImage-options\" class=\"headerlink\" title=\"1. 入口 setImageWithURL:placeholderImage:options:\"></a>1. 入口 <code>setImageWithURL:placeholderImage:options:</code></h2><blockquote>\n<p>会先把 <code>placeholderImage</code> 显示，然后 <code>SDWebImageManager</code> 根据 URL 开始处理图片。  </p>\n</blockquote>\n<h2 id=\"2-进入-SDWebImageManagerdownloadWithURL-delegate-options-userInfo\"><a href=\"#2-进入-SDWebImageManagerdownloadWithURL-delegate-options-userInfo\" class=\"headerlink\" title=\"2. 进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:\"></a>2. 进入 <code>SDWebImageManagerdownloadWithURL:delegate:options:userInfo:</code></h2><blockquote>\n<p>交给 <code>SDImageCache</code> 从缓存查找图片是否已经下载<br><code>queryDiskCacheForKey:delegate:userInfo:</code></p>\n</blockquote>\n<h2 id=\"3-先从内存图片缓存查找是否有图片\"><a href=\"#3-先从内存图片缓存查找是否有图片\" class=\"headerlink\" title=\"3. 先从内存图片缓存查找是否有图片\"></a>3. 先从内存图片缓存查找是否有图片</h2><blockquote>\n<p>如果内存中已经有图片缓存，<code>SDImageCacheDelegate</code> 回调 <code>imageCache:didFindImage:forKey:userInfo:</code> 到 <code>SDWebImageManager</code>，<code>SDWebImageManagerDelegate</code>回调 <code>webImageManager:didFinishWithImage:</code>到 <code>UIImageView+WebCache</code> 等前端展示图片</p>\n</blockquote>\n<h2 id=\"4-如果内存缓存中没有\"><a href=\"#4-如果内存缓存中没有\" class=\"headerlink\" title=\"4. 如果内存缓存中没有\"></a>4. 如果内存缓存中没有</h2><blockquote>\n<p>生成 <code>NSInvocationOperation</code><br>添加到队列开始从硬盘查找图片是否已经缓存  </p>\n</blockquote>\n<h2 id=\"5-根据-URLKey-在硬盘缓存目录下尝试读取图片文件\"><a href=\"#5-根据-URLKey-在硬盘缓存目录下尝试读取图片文件\" class=\"headerlink\" title=\"5. 根据 URLKey 在硬盘缓存目录下尝试读取图片文件\"></a>5. 根据 <code>URLKey</code> 在硬盘缓存目录下尝试读取图片文件</h2><blockquote>\n<p>这一步是在 <code>NSOperation</code> 进行的操作，所以回主线程进行结果回调 <code>notifyDelegate:</code></p>\n</blockquote>\n<h2 id=\"6-如果从硬盘读取到了图片\"><a href=\"#6-如果从硬盘读取到了图片\" class=\"headerlink\" title=\"6. 如果从硬盘读取到了图片\"></a>6. 如果从硬盘读取到了图片</h2><blockquote>\n<p>将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存），<code>SDImageCacheDelegate</code> 回调 <code>imageCache:didFindImage:forKey:userInfo:</code>。<br>进而回调展示图片</p>\n</blockquote>\n<h2 id=\"7-如果从硬盘缓存目录读取不到图片\"><a href=\"#7-如果从硬盘缓存目录读取不到图片\" class=\"headerlink\" title=\"7. 如果从硬盘缓存目录读取不到图片\"></a>7. 如果从硬盘缓存目录读取不到图片</h2><blockquote>\n<p>说明所有缓存都不存在该图片，需要下载图片，<br>回调 <code>imageCache:didNotFindImageForKey:userInfo:</code></p>\n</blockquote>\n<h2 id=\"8-下载图片\"><a href=\"#8-下载图片\" class=\"headerlink\" title=\"8. 下载图片\"></a>8. 下载图片</h2><blockquote>\n<p>共享或重新生成一个下载器 <code>SDWebImageDownloader</code> 开始下载图片。图片下载由 <code>NSURLConnection</code> 来做，<br>实现相关 <code>delegate</code> 来判断图片下载中、下载完成和下载失败。<br><code>connection:didReceiveData:</code> 中<br>利用 <code>ImageIO</code> 做了按图片下载进度加载效果</p>\n</blockquote>\n<h2 id=\"9-数据下载完成\"><a href=\"#9-数据下载完成\" class=\"headerlink\" title=\"9. 数据下载完成\"></a>9. 数据下载完成</h2><blockquote>\n<p><code>connectionDidFinishLoading:</code> 数据下载完成后交给 <code>SDWebImageDecoder</code> 做图片解码处理</p>\n</blockquote>\n<h2 id=\"10-图片解码\"><a href=\"#10-图片解码\" class=\"headerlink\" title=\"10. 图片解码\"></a>10. 图片解码</h2><blockquote>\n<p>图片解码处理在一个 NSOperationQueue 完成，<br>不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，<br>最好也在这里完成，效率会好很多。</p>\n</blockquote>\n<h2 id=\"11-解码完成\"><a href=\"#11-解码完成\" class=\"headerlink\" title=\"11. 解码完成\"></a>11. 解码完成</h2><blockquote>\n<p>在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code><br>宣告解码完成，<br><code>imageDecoder:didFinishDecodingImage:userInfo:</code><br>回调给 <code>SDWebImageDownloader</code>。</p>\n</blockquote>\n<h2 id=\"12-图片下载完成\"><a href=\"#12-图片下载完成\" class=\"headerlink\" title=\"12. 图片下载完成\"></a>12. 图片下载完成</h2><blockquote>\n<p><code>imageDownloader:didFinishWithImage:</code><br>回调给 <code>SDWebImageManager</code> 告知图片下载完成。<br>通知所有的 <code>downloadDelegates</code> 下载完成，<br>回调给需要的地方展示图片。</p>\n</blockquote>\n<h2 id=\"13-缓存图片\"><a href=\"#13-缓存图片\" class=\"headerlink\" title=\"13. 缓存图片\"></a>13. 缓存图片</h2><blockquote>\n<p>将图片保存到 <code>SDImageCache</code> 中，<br>内存缓存和硬盘缓存同时保存。<br>写文件到硬盘也在以单独 <code>NSInvocationOperation</code> 完成，<br>避免拖慢主线程。</p>\n</blockquote>\n<h2 id=\"14-其他\"><a href=\"#14-其他\" class=\"headerlink\" title=\"14. 其他\"></a>14. 其他</h2><blockquote>\n<ul>\n<li><code>SDImageCache</code> 在初始化的时候会注册一些消息通知<br>在内存警告或退到后台的时候清理内存图片缓存，<br>应用结束的时候清理过期图片。  </li>\n<li><code>SDWebImage</code> 也提供了 <code>UIButton+WebCache</code> 和<br><code>MKAnnotationView+WebCache</code>，方便使用。</li>\n<li><code>SDWebImagePrefetcher</code> 可以预先下载图片，<br>方便后续使用。</li>\n</ul>\n</blockquote>\n"},{"title":"Block本质是什么","date":"2017-11-25T11:40:16.000Z","_content":"\n - 底层实现  \n----------\n\n\n>  block是一个指针结构体，在终端下通过clang -rewrite-objc 指令查看C++代码。\n首先创建一个OS X 工程，写一个最简单的block  \n利用终端编译生成C++代码  \n{% asset_img pic1.jpeg 图片来源见水印 %}\nclang -rewrite-objc main.m\n>> 其中几个重要的结构体和函数简介：\n**__block_impl**：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;\n**__main_block_impl_0**: 可以理解为block变量;\n**__main_block_func_0**: 可以理解为匿名函数;\n**__main_block_desc_0**:block的描述, Block_size;  \n  \n\n1、__block_impl\n```\nstruct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};\n```\n\n2、__main_block_impl_0\n```\nstruct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {  impl.isa = &_NSConcreteStackBlock; impl.Flags = flags;  impl.FuncPtr = fp; Desc = desc; }};\n```\n\n3、__main_block_func_0\n```\nstatic void __main_block_func_0 (struct __main_block_impl_0 *__cself) { NSLog((NSString *)&__NSConstantStringImpl__var_folders_gc_ 5fkhcz0n6px48vzc744hmp6c0000gn_T_main_eef954_mi_0);\n```\n\n4、__main_block_desc_0\n```\nstatic struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main(int argc, const char * argv[]) {/* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void (*myblock)() = ((void (*) ())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA)); ((void (*)(__block_impl *)) ((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock); } return 0;}\n```\n\n - 注意事项\n----------\n> block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用  \n> 在MRC下用_block，在ARC下使用__weak;\n\n - 关于Block在内存中的位置\n----------\n> block块的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区，因此ARC下只有两个地方：代码区和堆区）。\n> \n>  - 代码区：\n    不访问栈区的变量（如局部变量），且不访问堆区的变量（如用alloc创建的对象）时，此时block存放在代码区；\n> \n>  - 堆区：\n    如果访问了堆区的变量（如局部变量），或堆区的变量（如用alloc创建的对象），此时block存方在堆区；需要注意\n> \n>  - 栈区：\n    在ARC情况下自动拷贝到堆区，如果不是ARC则存放在栈区，所在函数执行完毕就回释放，想再外面调用需要用copy指向它，这样就拷贝到了堆区，strong属性不会拷贝、会造成野指针错区。（需要理解ARC是一种编译器特性，即编译器在编译时在核实的地方插入retain、release、autorelease，而不是iOS的运行时特性）。\n>\nblock块代码存在堆区时,需要注意，因为堆区不像代码区不变化，堆区是动态的（不断的创建销毁），当没有强指针指向的时候就会被销毁，如果再去访问这段代码时，程序就会崩溃！所以此种情况在定义block属性时需要指定为strong or copy。block是一段代码，即不可变，所以使用copy也不会深拷贝。\n\n","source":"_posts/block本质是什么.md","raw":"---\ntitle: Block本质是什么\ndate: 2017-11-25 19:40:16\ntags: [iOS, Block]\ncategories: Question\n\n---\n\n - 底层实现  \n----------\n\n\n>  block是一个指针结构体，在终端下通过clang -rewrite-objc 指令查看C++代码。\n首先创建一个OS X 工程，写一个最简单的block  \n利用终端编译生成C++代码  \n{% asset_img pic1.jpeg 图片来源见水印 %}\nclang -rewrite-objc main.m\n>> 其中几个重要的结构体和函数简介：\n**__block_impl**：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;\n**__main_block_impl_0**: 可以理解为block变量;\n**__main_block_func_0**: 可以理解为匿名函数;\n**__main_block_desc_0**:block的描述, Block_size;  \n  \n\n1、__block_impl\n```\nstruct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};\n```\n\n2、__main_block_impl_0\n```\nstruct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {  impl.isa = &_NSConcreteStackBlock; impl.Flags = flags;  impl.FuncPtr = fp; Desc = desc; }};\n```\n\n3、__main_block_func_0\n```\nstatic void __main_block_func_0 (struct __main_block_impl_0 *__cself) { NSLog((NSString *)&__NSConstantStringImpl__var_folders_gc_ 5fkhcz0n6px48vzc744hmp6c0000gn_T_main_eef954_mi_0);\n```\n\n4、__main_block_desc_0\n```\nstatic struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main(int argc, const char * argv[]) {/* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void (*myblock)() = ((void (*) ())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA)); ((void (*)(__block_impl *)) ((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock); } return 0;}\n```\n\n - 注意事项\n----------\n> block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用  \n> 在MRC下用_block，在ARC下使用__weak;\n\n - 关于Block在内存中的位置\n----------\n> block块的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区，因此ARC下只有两个地方：代码区和堆区）。\n> \n>  - 代码区：\n    不访问栈区的变量（如局部变量），且不访问堆区的变量（如用alloc创建的对象）时，此时block存放在代码区；\n> \n>  - 堆区：\n    如果访问了堆区的变量（如局部变量），或堆区的变量（如用alloc创建的对象），此时block存方在堆区；需要注意\n> \n>  - 栈区：\n    在ARC情况下自动拷贝到堆区，如果不是ARC则存放在栈区，所在函数执行完毕就回释放，想再外面调用需要用copy指向它，这样就拷贝到了堆区，strong属性不会拷贝、会造成野指针错区。（需要理解ARC是一种编译器特性，即编译器在编译时在核实的地方插入retain、release、autorelease，而不是iOS的运行时特性）。\n>\nblock块代码存在堆区时,需要注意，因为堆区不像代码区不变化，堆区是动态的（不断的创建销毁），当没有强指针指向的时候就会被销毁，如果再去访问这段代码时，程序就会崩溃！所以此种情况在定义block属性时需要指定为strong or copy。block是一段代码，即不可变，所以使用copy也不会深拷贝。\n\n","slug":"block本质是什么","published":1,"updated":"2017-11-28T10:29:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz43f0006sku2gun935os","content":"<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\" - 底层实现  \"></a> - 底层实现  </h2><blockquote>\n<p> block是一个指针结构体，在终端下通过clang -rewrite-objc 指令查看C++代码。<br>首先创建一个OS X 工程，写一个最简单的block<br>利用终端编译生成C++代码<br><img src=\"/2017/11/25/block本质是什么/pic1.jpeg\" title=\"图片来源见水印\"><br>clang -rewrite-objc main.m</p>\n<blockquote>\n<p>其中几个重要的结构体和函数简介：<br><strong>__block_impl</strong>：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;<br><strong>__main_block_impl_0</strong>: 可以理解为block变量;<br><strong>__main_block_func_0</strong>: 可以理解为匿名函数;<br><strong>__main_block_desc_0</strong>:block的描述, Block_size;  </p>\n</blockquote>\n</blockquote>\n<p>1、__block_impl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>2、__main_block_impl_0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;  impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags;  impl.FuncPtr = fp; Desc = desc; &#125;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>3、__main_block_func_0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0 (struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gc_ 5fkhcz0n6px48vzc744hmp6c0000gn_T_main_eef954_mi_0);</span><br></pre></td></tr></table></figure></p>\n<p>4、__main_block_desc_0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123;/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; void (*myblock)() = ((void (*) ())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *)) ((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock); &#125; return 0;&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\" - 注意事项\"></a> - 注意事项</h2><blockquote>\n<p>block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用<br>在MRC下用_block，在ARC下使用__weak;</p>\n</blockquote>\n<h2 id=\"关于Block在内存中的位置\"><a href=\"#关于Block在内存中的位置\" class=\"headerlink\" title=\" - 关于Block在内存中的位置\"></a> - 关于Block在内存中的位置</h2><blockquote>\n<p>block块的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区，因此ARC下只有两个地方：代码区和堆区）。</p>\n<ul>\n<li><p>代码区：<br> 不访问栈区的变量（如局部变量），且不访问堆区的变量（如用alloc创建的对象）时，此时block存放在代码区；</p>\n</li>\n<li><p>堆区：<br> 如果访问了堆区的变量（如局部变量），或堆区的变量（如用alloc创建的对象），此时block存方在堆区；需要注意</p>\n</li>\n<li><p>栈区：<br> 在ARC情况下自动拷贝到堆区，如果不是ARC则存放在栈区，所在函数执行完毕就回释放，想再外面调用需要用copy指向它，这样就拷贝到了堆区，strong属性不会拷贝、会造成野指针错区。（需要理解ARC是一种编译器特性，即编译器在编译时在核实的地方插入retain、release、autorelease，而不是iOS的运行时特性）。</p>\n</li>\n</ul>\n<p>block块代码存在堆区时,需要注意，因为堆区不像代码区不变化，堆区是动态的（不断的创建销毁），当没有强指针指向的时候就会被销毁，如果再去访问这段代码时，程序就会崩溃！所以此种情况在定义block属性时需要指定为strong or copy。block是一段代码，即不可变，所以使用copy也不会深拷贝。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\" - 底层实现  \"></a> - 底层实现  </h2><blockquote>\n<p> block是一个指针结构体，在终端下通过clang -rewrite-objc 指令查看C++代码。<br>首先创建一个OS X 工程，写一个最简单的block<br>利用终端编译生成C++代码<br><img src=\"/2017/11/25/block本质是什么/pic1.jpeg\" title=\"图片来源见水印\"><br>clang -rewrite-objc main.m</p>\n<blockquote>\n<p>其中几个重要的结构体和函数简介：<br><strong>__block_impl</strong>：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;<br><strong>__main_block_impl_0</strong>: 可以理解为block变量;<br><strong>__main_block_func_0</strong>: 可以理解为匿名函数;<br><strong>__main_block_desc_0</strong>:block的描述, Block_size;  </p>\n</blockquote>\n</blockquote>\n<p>1、__block_impl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>2、__main_block_impl_0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;  impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags;  impl.FuncPtr = fp; Desc = desc; &#125;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>3、__main_block_func_0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0 (struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gc_ 5fkhcz0n6px48vzc744hmp6c0000gn_T_main_eef954_mi_0);</span><br></pre></td></tr></table></figure></p>\n<p>4、__main_block_desc_0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123;/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; void (*myblock)() = ((void (*) ())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *)) ((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock); &#125; return 0;&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\" - 注意事项\"></a> - 注意事项</h2><blockquote>\n<p>block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用<br>在MRC下用_block，在ARC下使用__weak;</p>\n</blockquote>\n<h2 id=\"关于Block在内存中的位置\"><a href=\"#关于Block在内存中的位置\" class=\"headerlink\" title=\" - 关于Block在内存中的位置\"></a> - 关于Block在内存中的位置</h2><blockquote>\n<p>block块的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区，因此ARC下只有两个地方：代码区和堆区）。</p>\n<ul>\n<li><p>代码区：<br> 不访问栈区的变量（如局部变量），且不访问堆区的变量（如用alloc创建的对象）时，此时block存放在代码区；</p>\n</li>\n<li><p>堆区：<br> 如果访问了堆区的变量（如局部变量），或堆区的变量（如用alloc创建的对象），此时block存方在堆区；需要注意</p>\n</li>\n<li><p>栈区：<br> 在ARC情况下自动拷贝到堆区，如果不是ARC则存放在栈区，所在函数执行完毕就回释放，想再外面调用需要用copy指向它，这样就拷贝到了堆区，strong属性不会拷贝、会造成野指针错区。（需要理解ARC是一种编译器特性，即编译器在编译时在核实的地方插入retain、release、autorelease，而不是iOS的运行时特性）。</p>\n</li>\n</ul>\n<p>block块代码存在堆区时,需要注意，因为堆区不像代码区不变化，堆区是动态的（不断的创建销毁），当没有强指针指向的时候就会被销毁，如果再去访问这段代码时，程序就会崩溃！所以此种情况在定义block属性时需要指定为strong or copy。block是一段代码，即不可变，所以使用copy也不会深拷贝。</p>\n</blockquote>\n"},{"title":"Swift中enum、struct、class三者异同","date":"2017-11-29T10:30:34.000Z","_content":"\n## 写在前面 ##\n由于在开发过程中常常需要用到系统提供的基础类型之外的的类型，所以`Swift`允许我们根据自己的需要构建属于自己的类型系统以便于更加灵活和方便的开发程序并将其称之为`named types`。\n`Swift`主要为我们提供了以下四种`named types` 分别是：`enum`、`struct`、`class`和`protocol`，  相信熟悉`objective-c`开发的同学们对于`iOS`中枚举、结构体和类的概念一点都不陌生。相比于`objective-c`中的这三者，`Swift`将`enum`和`struct`变得更加灵活且强大，并且赋予了他们很多和`class`相同的属性实现更加丰富多彩的功能，以至于有时候我们很难分清他们到底有什么区别以及我该什么时候用哪种类型，接下来本文将介绍在`Swift`中`enum`和`struct`的定义和新特性以及两者与`class`之间的异同。\n\n## 枚举（enum） ##\n\n - 枚举的定义\n`Swift`中的枚举是为一组有限种可能性的相关值提供的通用类型（在`C`/`C++`/`C#`中，枚举是一个被命名的整型常数的集合）；使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词`enum`来定义枚举，并在一对大括号内定义具体内容包括使用`case`关键字列举成员。就像下面一样：\n\n```swift\n//定义一个表示学生类型的全新枚举类型 StudentType，他有三个成员分别是pupil（小学生，）、middleSchoolStudent（中学生）、collegeStudents（大学生）\nenum StudentType {\n  case pupil\n  case middleSchoolStudent\n  case collegeStudent\n}\n```\n\n上面的代码可以读作：如果存在一个`StudentType`的实例，他要么是`pupil` （小学生）、要么是`middleSchoolStudent`（中学生）、要么是`collegeStudent`（大学生）。注意，和`C`、o`bjective-c`中枚举的不同，`Swift` 中的枚举成员在被创建时不会分配一个默认的整数值。而且不需要给枚举中的每一个成员都提供值(如果你需要也是可以的)。如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型（引自文档翻译）。简单说`Swift`中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值（不局限于整数类型）。\n枚举中有两个很容易混淆的概念：原始值(`raw value`)、关联值(`associated value`)，两个词听起来比较模糊，下面简单介绍一下：\n\n - 枚举的原始值(`raw value`)\n 枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(`raw value`)，下面的`StudentType`中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。注意：`Int`修饰的是`StudentType`成员原始值的类型而不是`StudentType`的类型，`StudentType`类型从定义开始就是一个全新的枚举类型。\n\n```swift\nenum StudentType: Int{\n    case pupil = 10\n    case middleSchoolStudent = 15\n    case collegeStudents = 20\n}\n```\n\n定义好`StudentType`成员的原始值之后，我们可以使用枚举成员的`rawValue`属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例\n\n```swift\n//  常量student1值是 10\nlet student1 = StudentType.pupil.rawValue\n//  变量student2值是 15\nvar student2 = StudentType.middleSchoolStudent.rawValue\n//  使用成员rawValue属性创建一个`StudentType`枚举的新实例\nlet student3 = StudentType.init(rawValue: 15)\n//  student3的值是 Optional<senson>.Type\ntype(of: student3)\n//  student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值\nlet student4 = StudentType.init(rawValue: 30)\n```\n\n使用原始值初始化器这种方式初始化创建得到`StudentType`的实例`student4`是一个`StudentType`的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在`StudentType`中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。\n总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。\n\n - 枚举的关联值(`associated value`)\n 关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码\n\n```swift\n//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudents\nenum StudentType {\n  case pupil(String)\n  case middleSchoolStudent(Int, String)\n  case collegeStudents(Int, String)\n}\n```\n\n这里我们并没有为`StudentType`的成员提供具体的值，而是为他们绑定了不同的类型，分别是`pupil`绑定`String`类型、mid`dleSchoolStudent`和`collegeStudents`绑定（`Int`， `String`）元组类型。接下来就可以创建不同`StudentType`枚举实例并为对应的成员赋值了。\n```swift\n//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是\"have fun\"（总是在玩耍）\nlet student1 = StudentType.pupil(\"have fun\")\n  //student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, \"always study\"（一周7天总是在学习）\nlet student2 = StudentType.middleSchoolStudent(7, \"always study\")\n  //student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, \"always LOL\"（一周7天总是在撸啊撸）\nlet student3 = StudentType.middleSchoolStudent(7, \"always LOL\")\n```\n\n这个时候如果需要判断某个`StudentType`实例的具体的值就需要这样做了：\n\n```swift\nswitch student3 {\n    case .pupil(let things):\n        print(\"is a pupil and \\(things)\")\n    case .middleSchoolStudent(let day, let things):\n        print(\"is a middleSchoolStudent and \\(day) days \\(things)\")\n    case .collegeStudent(let day, let things):\n        print(\"is a collegeStudent and \\(day) days \\(things)\")\n  }\n```\n\n控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。\n\n - 递归枚举\n 递归枚举是拥有另一个枚举作为枚举成员关联值的枚举（引自文档翻译）。\n关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。下面是一个经典的通过递归算法求解n!（阶乘）的函数。\n\n```swift\nfunc factorial(n: Int)->Int {\n    if n > 0 {\n        return n * factorial(n: n - 1)\n    } else {\n        return 1\n    }\n}\n//1 * 2 * 3 * 4 * 5 * 6 = 720\nlet sum = factorial(n: 6)\n```\n\n函数`factorial (n: int)-> Int`在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。\n\n\n## 结构体（struct） ##\n\n - 结构体的定义\n 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在`Swift`中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。我们通过使用关键词`struct`来定义结构体。并在一对大括号内定义具体内容包括他的成员和自定义的方法（是的，`Swift`中的结构体有方法了），定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。废话不多说直接上代码:\n\n```swift\n//定义一个 Student（学生）类型的结构体用于表示一个学生，Student的成员分别是语、数、外三科`Int`类型的成绩\nstruct Student {\n  var chinese: Int\n  var math: Int\n  var english: Int\n}\n```\n\n看到这里熟悉`Swift`的同学可能已经发现了一点结构体和类的区别了：定义结构体类型时其成员可以没有初始值。如果使用这种格式定义一个类，编译器是会报错的，他会提醒你这个类没有被初始化。\n\n - 结构体实例的创建\n 创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。最简单的语法是在类或结构体名字后面接一个空的圆括号，例如 `let student1 = Student()`。这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。但是结合上面的代码，由于在定义Student结构体时我们并没有为他的成员赋初值，所以 `let student1 = Student()`在编译器中报错了，此处报错并不是因为不能这样创建实例而是因为`student1`成员没有默认值，所以我们可以使用下面的方式创建实例:\n\n```swift\n//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）\nlet student2 = Student(chinese: 90, math: 80, english: 70)\n```\n\n所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义`Student`时为他的成员赋上初值，那么下面的代码是编译通过的：\n\n```swift\nstruct Student {\n  var chinese: Int = 50\n  var math: Int = 50\n  var english: Int = 50\n}\nlet student2 = Student(chinese: 90, math: 80, english: 70)\nlet student4 = Student()\n```\n\n总结一句：定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。\n\n - 自定义的初始化器\n 当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过形如 `let student5 = Student(stringScore: \"70,80,90\")` 的方式创建实例时，就需要自定义初始化方法了：\n\n```swift\nstruct Student {\n  var chinese: Int = 50\n  var math: Int = 50\n  var english: Int = 50\n      init() {}\n      init(chinese: Int, math: Int, english: Int) {\n            self.chinese = chinese\n            self.math = math\n           self.english = english\n      }\n      init(stringScore: String) {\n           let cme = stringScore.characters.split(separator: \",\")\n           chinese = Int(atoi(String(cme.first!)))\n           math = Int(atoi(String(cme[1])))\n           english = Int(atoi(String(cme.last!)))\n      }\n  }\n  let student6 = Student()\n  let student7 = Student(chinese: 90, math: 80, english: 70)\n  let student8 = Student(stringScore: \"70,80,90\")\n```\n\n一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。\n\n - 定义其他方法\n如果此时需要修改某个学生某科的成绩，该如何实现呢？当然，我们可以定义下面的方法：\n\n```swift\n//更改某个学生某门学科的成绩\nfunc changeChinese(num: Int, student: inout Student){\n  student.chinese += num\n}\nchangeChinese(num: 20, student: &student7)\n```\n\n此时`student7`的语文成绩就由原来的`90`被修改到了`110`，但是此方法有两个明显的弊端：1，学生的语文成绩`chinese`是`Student`结构体的内部成员，一个学生的某科成绩无需被`Student`的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。2，更改一个学生的语文成绩本身就是和`Student`结构体内部成员计算相关的事情，我们更希望达到形如：`student7.changeChinese(num: 10)` 的效果，因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时`changeChinese(num:)`方法是`Student`结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比：\n\n```swift\nstruct Student {\n    var chinese: Int = 50\n    var math: Int = 50\n    var english: Int = 50\n   //修改数学成绩\n    mutating func changeMath(num: Int) {\n        self.math += num\n    }\n  }\n  var student7 = Student(chinese: 20, math: 30, english: 40)\n  //更改分数中语文学科的成绩\n  func changeChinese(num: Int, student: inout Student){\n      student.chinese += num\n    }\n  changeChinese(num: 20, student: &student7)\n  student7.changeMath(num: 10)\n```\n\n尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为`Student`结构体内部添加`changeMath(num:)`的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：`mutating`关键字。由于结构体是值类型，`Swift`规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用`mutating`我们便可以办到这点，当然这也是和类的不同点。\n\n- 常见的结构体\n`Swift`中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型：\n\n```swift\n//表示数值类型的结构体：\n  Int，Float，Double，CGFloat...\n//表示字符和字符串类型的结构体\n  Character，String...\n//位置和尺寸的结构体\n  CGPoint，CGSize...\n//集合类型结构体\n  Array，Set，Dictionary...\n```\n\n很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况\n\n```swift\n// Person 类\nclass Person {\n    var name: String = \"jack\"\n    let life: Int = 1\n}\n    var s1 = Person()\n    var s2 = s1\n     s2.name = \"mike\"\n```\n\n```swift\n// People 结构体数据结构\nstruct People {\n    var name: String = \"jack\"\n    let life: Int = 1\n}\n    var p1 = People()\n    var p2 = p1\n      p2.name = \"mike\"\n```\n\n细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是因为 `struct` 是值引用，`class` 是类型引用。\n\n## 总结 ##\n\n> 枚举、结构体、类的共同点：\n>\n - 定义属性和方法；\n - 下标语法访问值；\n - 初始化器；\n - 支持扩展增加功能；\n - 可以遵循协议；\n> \n> 类特有的功能；\n>\n - 继承；\n - 允许类型转换；\n - 析构方法释放资源；\n - 引用计数；\n \n \n \n 类是引用类型\n> 引用类型(`reference types`，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。\n\n枚举，结构体是值类型\n> 值类型(`value types`)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。\n\n该如何选择\n\n> 关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）：\n>> 当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：\n1.什么时候该用值类型：\n要用==运算符来比较实例的数据时\n你希望那个实例的拷贝能保持独立的状态时\n数据会被多个线程使用时  \n2.什么时候该用引用类型（class）：   \n要用==运算符来比较实例身份的时候\n你希望有创建一个共享的、可变对象的时候","source":"_posts/Swift中enum、struct、class三者异同.md","raw":"---\ntitle: Swift中enum、struct、class三者异同\ndate: 2017-11-29 18:30:34\ntags: [Swift, Class, Enum, Struct]\ncategories: Swift\n---\n\n## 写在前面 ##\n由于在开发过程中常常需要用到系统提供的基础类型之外的的类型，所以`Swift`允许我们根据自己的需要构建属于自己的类型系统以便于更加灵活和方便的开发程序并将其称之为`named types`。\n`Swift`主要为我们提供了以下四种`named types` 分别是：`enum`、`struct`、`class`和`protocol`，  相信熟悉`objective-c`开发的同学们对于`iOS`中枚举、结构体和类的概念一点都不陌生。相比于`objective-c`中的这三者，`Swift`将`enum`和`struct`变得更加灵活且强大，并且赋予了他们很多和`class`相同的属性实现更加丰富多彩的功能，以至于有时候我们很难分清他们到底有什么区别以及我该什么时候用哪种类型，接下来本文将介绍在`Swift`中`enum`和`struct`的定义和新特性以及两者与`class`之间的异同。\n\n## 枚举（enum） ##\n\n - 枚举的定义\n`Swift`中的枚举是为一组有限种可能性的相关值提供的通用类型（在`C`/`C++`/`C#`中，枚举是一个被命名的整型常数的集合）；使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词`enum`来定义枚举，并在一对大括号内定义具体内容包括使用`case`关键字列举成员。就像下面一样：\n\n```swift\n//定义一个表示学生类型的全新枚举类型 StudentType，他有三个成员分别是pupil（小学生，）、middleSchoolStudent（中学生）、collegeStudents（大学生）\nenum StudentType {\n  case pupil\n  case middleSchoolStudent\n  case collegeStudent\n}\n```\n\n上面的代码可以读作：如果存在一个`StudentType`的实例，他要么是`pupil` （小学生）、要么是`middleSchoolStudent`（中学生）、要么是`collegeStudent`（大学生）。注意，和`C`、o`bjective-c`中枚举的不同，`Swift` 中的枚举成员在被创建时不会分配一个默认的整数值。而且不需要给枚举中的每一个成员都提供值(如果你需要也是可以的)。如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型（引自文档翻译）。简单说`Swift`中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值（不局限于整数类型）。\n枚举中有两个很容易混淆的概念：原始值(`raw value`)、关联值(`associated value`)，两个词听起来比较模糊，下面简单介绍一下：\n\n - 枚举的原始值(`raw value`)\n 枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(`raw value`)，下面的`StudentType`中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。注意：`Int`修饰的是`StudentType`成员原始值的类型而不是`StudentType`的类型，`StudentType`类型从定义开始就是一个全新的枚举类型。\n\n```swift\nenum StudentType: Int{\n    case pupil = 10\n    case middleSchoolStudent = 15\n    case collegeStudents = 20\n}\n```\n\n定义好`StudentType`成员的原始值之后，我们可以使用枚举成员的`rawValue`属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例\n\n```swift\n//  常量student1值是 10\nlet student1 = StudentType.pupil.rawValue\n//  变量student2值是 15\nvar student2 = StudentType.middleSchoolStudent.rawValue\n//  使用成员rawValue属性创建一个`StudentType`枚举的新实例\nlet student3 = StudentType.init(rawValue: 15)\n//  student3的值是 Optional<senson>.Type\ntype(of: student3)\n//  student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值\nlet student4 = StudentType.init(rawValue: 30)\n```\n\n使用原始值初始化器这种方式初始化创建得到`StudentType`的实例`student4`是一个`StudentType`的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在`StudentType`中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。\n总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。\n\n - 枚举的关联值(`associated value`)\n 关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码\n\n```swift\n//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudents\nenum StudentType {\n  case pupil(String)\n  case middleSchoolStudent(Int, String)\n  case collegeStudents(Int, String)\n}\n```\n\n这里我们并没有为`StudentType`的成员提供具体的值，而是为他们绑定了不同的类型，分别是`pupil`绑定`String`类型、mid`dleSchoolStudent`和`collegeStudents`绑定（`Int`， `String`）元组类型。接下来就可以创建不同`StudentType`枚举实例并为对应的成员赋值了。\n```swift\n//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是\"have fun\"（总是在玩耍）\nlet student1 = StudentType.pupil(\"have fun\")\n  //student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, \"always study\"（一周7天总是在学习）\nlet student2 = StudentType.middleSchoolStudent(7, \"always study\")\n  //student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, \"always LOL\"（一周7天总是在撸啊撸）\nlet student3 = StudentType.middleSchoolStudent(7, \"always LOL\")\n```\n\n这个时候如果需要判断某个`StudentType`实例的具体的值就需要这样做了：\n\n```swift\nswitch student3 {\n    case .pupil(let things):\n        print(\"is a pupil and \\(things)\")\n    case .middleSchoolStudent(let day, let things):\n        print(\"is a middleSchoolStudent and \\(day) days \\(things)\")\n    case .collegeStudent(let day, let things):\n        print(\"is a collegeStudent and \\(day) days \\(things)\")\n  }\n```\n\n控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。\n\n - 递归枚举\n 递归枚举是拥有另一个枚举作为枚举成员关联值的枚举（引自文档翻译）。\n关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。下面是一个经典的通过递归算法求解n!（阶乘）的函数。\n\n```swift\nfunc factorial(n: Int)->Int {\n    if n > 0 {\n        return n * factorial(n: n - 1)\n    } else {\n        return 1\n    }\n}\n//1 * 2 * 3 * 4 * 5 * 6 = 720\nlet sum = factorial(n: 6)\n```\n\n函数`factorial (n: int)-> Int`在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。\n\n\n## 结构体（struct） ##\n\n - 结构体的定义\n 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在`Swift`中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。我们通过使用关键词`struct`来定义结构体。并在一对大括号内定义具体内容包括他的成员和自定义的方法（是的，`Swift`中的结构体有方法了），定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。废话不多说直接上代码:\n\n```swift\n//定义一个 Student（学生）类型的结构体用于表示一个学生，Student的成员分别是语、数、外三科`Int`类型的成绩\nstruct Student {\n  var chinese: Int\n  var math: Int\n  var english: Int\n}\n```\n\n看到这里熟悉`Swift`的同学可能已经发现了一点结构体和类的区别了：定义结构体类型时其成员可以没有初始值。如果使用这种格式定义一个类，编译器是会报错的，他会提醒你这个类没有被初始化。\n\n - 结构体实例的创建\n 创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。最简单的语法是在类或结构体名字后面接一个空的圆括号，例如 `let student1 = Student()`。这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。但是结合上面的代码，由于在定义Student结构体时我们并没有为他的成员赋初值，所以 `let student1 = Student()`在编译器中报错了，此处报错并不是因为不能这样创建实例而是因为`student1`成员没有默认值，所以我们可以使用下面的方式创建实例:\n\n```swift\n//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）\nlet student2 = Student(chinese: 90, math: 80, english: 70)\n```\n\n所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义`Student`时为他的成员赋上初值，那么下面的代码是编译通过的：\n\n```swift\nstruct Student {\n  var chinese: Int = 50\n  var math: Int = 50\n  var english: Int = 50\n}\nlet student2 = Student(chinese: 90, math: 80, english: 70)\nlet student4 = Student()\n```\n\n总结一句：定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。\n\n - 自定义的初始化器\n 当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过形如 `let student5 = Student(stringScore: \"70,80,90\")` 的方式创建实例时，就需要自定义初始化方法了：\n\n```swift\nstruct Student {\n  var chinese: Int = 50\n  var math: Int = 50\n  var english: Int = 50\n      init() {}\n      init(chinese: Int, math: Int, english: Int) {\n            self.chinese = chinese\n            self.math = math\n           self.english = english\n      }\n      init(stringScore: String) {\n           let cme = stringScore.characters.split(separator: \",\")\n           chinese = Int(atoi(String(cme.first!)))\n           math = Int(atoi(String(cme[1])))\n           english = Int(atoi(String(cme.last!)))\n      }\n  }\n  let student6 = Student()\n  let student7 = Student(chinese: 90, math: 80, english: 70)\n  let student8 = Student(stringScore: \"70,80,90\")\n```\n\n一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。\n\n - 定义其他方法\n如果此时需要修改某个学生某科的成绩，该如何实现呢？当然，我们可以定义下面的方法：\n\n```swift\n//更改某个学生某门学科的成绩\nfunc changeChinese(num: Int, student: inout Student){\n  student.chinese += num\n}\nchangeChinese(num: 20, student: &student7)\n```\n\n此时`student7`的语文成绩就由原来的`90`被修改到了`110`，但是此方法有两个明显的弊端：1，学生的语文成绩`chinese`是`Student`结构体的内部成员，一个学生的某科成绩无需被`Student`的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。2，更改一个学生的语文成绩本身就是和`Student`结构体内部成员计算相关的事情，我们更希望达到形如：`student7.changeChinese(num: 10)` 的效果，因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时`changeChinese(num:)`方法是`Student`结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比：\n\n```swift\nstruct Student {\n    var chinese: Int = 50\n    var math: Int = 50\n    var english: Int = 50\n   //修改数学成绩\n    mutating func changeMath(num: Int) {\n        self.math += num\n    }\n  }\n  var student7 = Student(chinese: 20, math: 30, english: 40)\n  //更改分数中语文学科的成绩\n  func changeChinese(num: Int, student: inout Student){\n      student.chinese += num\n    }\n  changeChinese(num: 20, student: &student7)\n  student7.changeMath(num: 10)\n```\n\n尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为`Student`结构体内部添加`changeMath(num:)`的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：`mutating`关键字。由于结构体是值类型，`Swift`规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用`mutating`我们便可以办到这点，当然这也是和类的不同点。\n\n- 常见的结构体\n`Swift`中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型：\n\n```swift\n//表示数值类型的结构体：\n  Int，Float，Double，CGFloat...\n//表示字符和字符串类型的结构体\n  Character，String...\n//位置和尺寸的结构体\n  CGPoint，CGSize...\n//集合类型结构体\n  Array，Set，Dictionary...\n```\n\n很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况\n\n```swift\n// Person 类\nclass Person {\n    var name: String = \"jack\"\n    let life: Int = 1\n}\n    var s1 = Person()\n    var s2 = s1\n     s2.name = \"mike\"\n```\n\n```swift\n// People 结构体数据结构\nstruct People {\n    var name: String = \"jack\"\n    let life: Int = 1\n}\n    var p1 = People()\n    var p2 = p1\n      p2.name = \"mike\"\n```\n\n细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是因为 `struct` 是值引用，`class` 是类型引用。\n\n## 总结 ##\n\n> 枚举、结构体、类的共同点：\n>\n - 定义属性和方法；\n - 下标语法访问值；\n - 初始化器；\n - 支持扩展增加功能；\n - 可以遵循协议；\n> \n> 类特有的功能；\n>\n - 继承；\n - 允许类型转换；\n - 析构方法释放资源；\n - 引用计数；\n \n \n \n 类是引用类型\n> 引用类型(`reference types`，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。\n\n枚举，结构体是值类型\n> 值类型(`value types`)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。\n\n该如何选择\n\n> 关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）：\n>> 当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：\n1.什么时候该用值类型：\n要用==运算符来比较实例的数据时\n你希望那个实例的拷贝能保持独立的状态时\n数据会被多个线程使用时  \n2.什么时候该用引用类型（class）：   \n要用==运算符来比较实例身份的时候\n你希望有创建一个共享的、可变对象的时候","slug":"Swift中enum、struct、class三者异同","published":1,"updated":"2017-11-30T01:37:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz43h0007sku2vgzgkks7","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>由于在开发过程中常常需要用到系统提供的基础类型之外的的类型，所以<code>Swift</code>允许我们根据自己的需要构建属于自己的类型系统以便于更加灵活和方便的开发程序并将其称之为<code>named types</code>。<br><code>Swift</code>主要为我们提供了以下四种<code>named types</code> 分别是：<code>enum</code>、<code>struct</code>、<code>class</code>和<code>protocol</code>，  相信熟悉<code>objective-c</code>开发的同学们对于<code>iOS</code>中枚举、结构体和类的概念一点都不陌生。相比于<code>objective-c</code>中的这三者，<code>Swift</code>将<code>enum</code>和<code>struct</code>变得更加灵活且强大，并且赋予了他们很多和<code>class</code>相同的属性实现更加丰富多彩的功能，以至于有时候我们很难分清他们到底有什么区别以及我该什么时候用哪种类型，接下来本文将介绍在<code>Swift</code>中<code>enum</code>和<code>struct</code>的定义和新特性以及两者与<code>class</code>之间的异同。</p>\n<h2 id=\"枚举（enum）\"><a href=\"#枚举（enum）\" class=\"headerlink\" title=\"枚举（enum）\"></a>枚举（enum）</h2><ul>\n<li>枚举的定义<br><code>Swift</code>中的枚举是为一组有限种可能性的相关值提供的通用类型（在<code>C</code>/<code>C++</code>/<code>C#</code>中，枚举是一个被命名的整型常数的集合）；使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词<code>enum</code>来定义枚举，并在一对大括号内定义具体内容包括使用<code>case</code>关键字列举成员。就像下面一样：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个表示学生类型的全新枚举类型 StudentType，他有三个成员分别是pupil（小学生，）、middleSchoolStudent（中学生）、collegeStudents（大学生）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StudentType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> pupil</span><br><span class=\"line\">  <span class=\"keyword\">case</span> middleSchoolStudent</span><br><span class=\"line\">  <span class=\"keyword\">case</span> collegeStudent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以读作：如果存在一个<code>StudentType</code>的实例，他要么是<code>pupil</code> （小学生）、要么是<code>middleSchoolStudent</code>（中学生）、要么是<code>collegeStudent</code>（大学生）。注意，和<code>C</code>、o<code>bjective-c</code>中枚举的不同，<code>Swift</code> 中的枚举成员在被创建时不会分配一个默认的整数值。而且不需要给枚举中的每一个成员都提供值(如果你需要也是可以的)。如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型（引自文档翻译）。简单说<code>Swift</code>中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值（不局限于整数类型）。<br>枚举中有两个很容易混淆的概念：原始值(<code>raw value</code>)、关联值(<code>associated value</code>)，两个词听起来比较模糊，下面简单介绍一下：</p>\n<ul>\n<li>枚举的原始值(<code>raw value</code>)<br>枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(<code>raw value</code>)，下面的<code>StudentType</code>中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。注意：<code>Int</code>修饰的是<code>StudentType</code>成员原始值的类型而不是<code>StudentType</code>的类型，<code>StudentType</code>类型从定义开始就是一个全新的枚举类型。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StudentType</span>: <span class=\"title\">Int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> pupil = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> middleSchoolStudent = <span class=\"number\">15</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> collegeStudents = <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好<code>StudentType</code>成员的原始值之后，我们可以使用枚举成员的<code>rawValue</code>属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  常量student1值是 10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student1 = <span class=\"type\">StudentType</span>.pupil.rawValue</span><br><span class=\"line\"><span class=\"comment\">//  变量student2值是 15</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> student2 = <span class=\"type\">StudentType</span>.middleSchoolStudent.rawValue</span><br><span class=\"line\"><span class=\"comment\">//  使用成员rawValue属性创建一个`StudentType`枚举的新实例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student3 = <span class=\"type\">StudentType</span>.<span class=\"keyword\">init</span>(rawValue: <span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"comment\">//  student3的值是 Optional&lt;senson&gt;.Type</span></span><br><span class=\"line\">type(of: student3)</span><br><span class=\"line\"><span class=\"comment\">//  student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student4 = <span class=\"type\">StudentType</span>.<span class=\"keyword\">init</span>(rawValue: <span class=\"number\">30</span>)</span><br></pre></td></tr></table></figure>\n<p>使用原始值初始化器这种方式初始化创建得到<code>StudentType</code>的实例<code>student4</code>是一个<code>StudentType</code>的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在<code>StudentType</code>中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。<br>总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。</p>\n<ul>\n<li>枚举的关联值(<code>associated value</code>)<br>关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudents</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StudentType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> pupil(<span class=\"type\">String</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> middleSchoolStudent(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> collegeStudents(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们并没有为<code>StudentType</code>的成员提供具体的值，而是为他们绑定了不同的类型，分别是<code>pupil</code>绑定<code>String</code>类型、mid<code>dleSchoolStudent</code>和<code>collegeStudents</code>绑定（<code>Int</code>， <code>String</code>）元组类型。接下来就可以创建不同<code>StudentType</code>枚举实例并为对应的成员赋值了。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是\"have fun\"（总是在玩耍）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student1 = <span class=\"type\">StudentType</span>.pupil(<span class=\"string\">\"have fun\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">//student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, \"always study\"（一周7天总是在学习）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student2 = <span class=\"type\">StudentType</span>.middleSchoolStudent(<span class=\"number\">7</span>, <span class=\"string\">\"always study\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">//student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, \"always LOL\"（一周7天总是在撸啊撸）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student3 = <span class=\"type\">StudentType</span>.middleSchoolStudent(<span class=\"number\">7</span>, <span class=\"string\">\"always LOL\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候如果需要判断某个<code>StudentType</code>实例的具体的值就需要这样做了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> student3 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .pupil(<span class=\"keyword\">let</span> things):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"is a pupil and <span class=\"subst\">\\(things)</span>\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .middleSchoolStudent(<span class=\"keyword\">let</span> day, <span class=\"keyword\">let</span> things):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"is a middleSchoolStudent and <span class=\"subst\">\\(day)</span> days <span class=\"subst\">\\(things)</span>\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .collegeStudent(<span class=\"keyword\">let</span> day, <span class=\"keyword\">let</span> things):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"is a collegeStudent and <span class=\"subst\">\\(day)</span> days <span class=\"subst\">\\(things)</span>\"</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。</p>\n<ul>\n<li>递归枚举<br>递归枚举是拥有另一个枚举作为枚举成员关联值的枚举（引自文档翻译）。<br>关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。下面是一个经典的通过递归算法求解n!（阶乘）的函数。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">factorial</span><span class=\"params\">(n: Int)</span></span>-&gt;<span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n: n - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1 * 2 * 3 * 4 * 5 * 6 = 720</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sum = factorial(n: <span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<p>函数<code>factorial (n: int)-&gt; Int</code>在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。</p>\n<h2 id=\"结构体（struct）\"><a href=\"#结构体（struct）\" class=\"headerlink\" title=\"结构体（struct）\"></a>结构体（struct）</h2><ul>\n<li>结构体的定义<br>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在<code>Swift</code>中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。我们通过使用关键词<code>struct</code>来定义结构体。并在一对大括号内定义具体内容包括他的成员和自定义的方法（是的，<code>Swift</code>中的结构体有方法了），定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。废话不多说直接上代码:</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个 Student（学生）类型的结构体用于表示一个学生，Student的成员分别是语、数、外三科`Int`类型的成绩</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里熟悉<code>Swift</code>的同学可能已经发现了一点结构体和类的区别了：定义结构体类型时其成员可以没有初始值。如果使用这种格式定义一个类，编译器是会报错的，他会提醒你这个类没有被初始化。</p>\n<ul>\n<li>结构体实例的创建<br>创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。最简单的语法是在类或结构体名字后面接一个空的圆括号，例如 <code>let student1 = Student()</code>。这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。但是结合上面的代码，由于在定义Student结构体时我们并没有为他的成员赋初值，所以 <code>let student1 = Student()</code>在编译器中报错了，此处报错并不是因为不能这样创建实例而是因为<code>student1</code>成员没有默认值，所以我们可以使用下面的方式创建实例:</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student2 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">90</span>, math: <span class=\"number\">80</span>, english: <span class=\"number\">70</span>)</span><br></pre></td></tr></table></figure>\n<p>所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义<code>Student</code>时为他的成员赋上初值，那么下面的代码是编译通过的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> student2 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">90</span>, math: <span class=\"number\">80</span>, english: <span class=\"number\">70</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> student4 = <span class=\"type\">Student</span>()</span><br></pre></td></tr></table></figure>\n<p>总结一句：定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。</p>\n<ul>\n<li>自定义的初始化器<br>当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过形如 <code>let student5 = Student(stringScore: &quot;70,80,90&quot;)</code> 的方式创建实例时，就需要自定义初始化方法了：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">      <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">init</span>(chinese: <span class=\"type\">Int</span>, math: <span class=\"type\">Int</span>, english: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chinese = chinese</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.math = math</span><br><span class=\"line\">           <span class=\"keyword\">self</span>.english = english</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">init</span>(stringScore: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">let</span> cme = stringScore.characters.<span class=\"built_in\">split</span>(separator: <span class=\"string\">\",\"</span>)</span><br><span class=\"line\">           chinese = <span class=\"type\">Int</span>(atoi(<span class=\"type\">String</span>(cme.first!)))</span><br><span class=\"line\">           math = <span class=\"type\">Int</span>(atoi(<span class=\"type\">String</span>(cme[<span class=\"number\">1</span>])))</span><br><span class=\"line\">           english = <span class=\"type\">Int</span>(atoi(<span class=\"type\">String</span>(cme.last!)))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> student6 = <span class=\"type\">Student</span>()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> student7 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">90</span>, math: <span class=\"number\">80</span>, english: <span class=\"number\">70</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> student8 = <span class=\"type\">Student</span>(stringScore: <span class=\"string\">\"70,80,90\"</span>)</span><br></pre></td></tr></table></figure>\n<p>一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。</p>\n<ul>\n<li>定义其他方法<br>如果此时需要修改某个学生某科的成绩，该如何实现呢？当然，我们可以定义下面的方法：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更改某个学生某门学科的成绩</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeChinese</span><span class=\"params\">(num: Int, student: <span class=\"keyword\">inout</span> Student)</span></span>&#123;</span><br><span class=\"line\">  student.chinese += num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">changeChinese(num: <span class=\"number\">20</span>, student: &amp;student7)</span><br></pre></td></tr></table></figure>\n<p>此时<code>student7</code>的语文成绩就由原来的<code>90</code>被修改到了<code>110</code>，但是此方法有两个明显的弊端：1，学生的语文成绩<code>chinese</code>是<code>Student</code>结构体的内部成员，一个学生的某科成绩无需被<code>Student</code>的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。2，更改一个学生的语文成绩本身就是和<code>Student</code>结构体内部成员计算相关的事情，我们更希望达到形如：<code>student7.changeChinese(num: 10)</code> 的效果，因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时<code>changeChinese(num:)</code>方法是<code>Student</code>结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">   <span class=\"comment\">//修改数学成绩</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeMath</span><span class=\"params\">(num: Int)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.math += num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> student7 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">20</span>, math: <span class=\"number\">30</span>, english: <span class=\"number\">40</span>)</span><br><span class=\"line\">  <span class=\"comment\">//更改分数中语文学科的成绩</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeChinese</span><span class=\"params\">(num: Int, student: <span class=\"keyword\">inout</span> Student)</span></span>&#123;</span><br><span class=\"line\">      student.chinese += num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  changeChinese(num: <span class=\"number\">20</span>, student: &amp;student7)</span><br><span class=\"line\">  student7.changeMath(num: <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为<code>Student</code>结构体内部添加<code>changeMath(num:)</code>的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：<code>mutating</code>关键字。由于结构体是值类型，<code>Swift</code>规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用<code>mutating</code>我们便可以办到这点，当然这也是和类的不同点。</p>\n<ul>\n<li>常见的结构体<br><code>Swift</code>中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示数值类型的结构体：</span></span><br><span class=\"line\">  <span class=\"type\">Int</span>，<span class=\"type\">Float</span>，<span class=\"type\">Double</span>，<span class=\"type\">CGFloat</span>...</span><br><span class=\"line\"><span class=\"comment\">//表示字符和字符串类型的结构体</span></span><br><span class=\"line\">  <span class=\"type\">Character</span>，<span class=\"type\">String</span>...</span><br><span class=\"line\"><span class=\"comment\">//位置和尺寸的结构体</span></span><br><span class=\"line\">  <span class=\"type\">CGPoint</span>，<span class=\"type\">CGSize</span>...</span><br><span class=\"line\"><span class=\"comment\">//集合类型结构体</span></span><br><span class=\"line\">  <span class=\"type\">Array</span>，<span class=\"type\">Set</span>，<span class=\"type\">Dictionary</span>...</span><br></pre></td></tr></table></figure>\n<p>很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Person 类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = <span class=\"string\">\"jack\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> life: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s1 = <span class=\"type\">Person</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s2 = s1</span><br><span class=\"line\">     s2.name = <span class=\"string\">\"mike\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// People 结构体数据结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = <span class=\"string\">\"jack\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> life: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p1 = <span class=\"type\">People</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p2 = p1</span><br><span class=\"line\">      p2.name = <span class=\"string\">\"mike\"</span></span><br></pre></td></tr></table></figure>\n<p>细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是因为 <code>struct</code> 是值引用，<code>class</code> 是类型引用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>枚举、结构体、类的共同点：</p>\n<ul>\n<li>定义属性和方法；</li>\n<li>下标语法访问值；</li>\n<li>初始化器；</li>\n<li>支持扩展增加功能；</li>\n<li>可以遵循协议；</li>\n</ul>\n<p>类特有的功能；</p>\n<ul>\n<li>继承；</li>\n<li>允许类型转换；</li>\n<li>析构方法释放资源；</li>\n<li>引用计数；</li>\n</ul>\n</blockquote>\n<p> 类是引用类型</p>\n<blockquote>\n<p>引用类型(<code>reference types</code>，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。</p>\n</blockquote>\n<p>枚举，结构体是值类型</p>\n<blockquote>\n<p>值类型(<code>value types</code>)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。</p>\n</blockquote>\n<p>该如何选择</p>\n<blockquote>\n<p>关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）：</p>\n<blockquote>\n<p>当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：<br>1.什么时候该用值类型：<br>要用==运算符来比较实例的数据时<br>你希望那个实例的拷贝能保持独立的状态时<br>数据会被多个线程使用时<br>2.什么时候该用引用类型（class）：<br>要用==运算符来比较实例身份的时候<br>你希望有创建一个共享的、可变对象的时候</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>由于在开发过程中常常需要用到系统提供的基础类型之外的的类型，所以<code>Swift</code>允许我们根据自己的需要构建属于自己的类型系统以便于更加灵活和方便的开发程序并将其称之为<code>named types</code>。<br><code>Swift</code>主要为我们提供了以下四种<code>named types</code> 分别是：<code>enum</code>、<code>struct</code>、<code>class</code>和<code>protocol</code>，  相信熟悉<code>objective-c</code>开发的同学们对于<code>iOS</code>中枚举、结构体和类的概念一点都不陌生。相比于<code>objective-c</code>中的这三者，<code>Swift</code>将<code>enum</code>和<code>struct</code>变得更加灵活且强大，并且赋予了他们很多和<code>class</code>相同的属性实现更加丰富多彩的功能，以至于有时候我们很难分清他们到底有什么区别以及我该什么时候用哪种类型，接下来本文将介绍在<code>Swift</code>中<code>enum</code>和<code>struct</code>的定义和新特性以及两者与<code>class</code>之间的异同。</p>\n<h2 id=\"枚举（enum）\"><a href=\"#枚举（enum）\" class=\"headerlink\" title=\"枚举（enum）\"></a>枚举（enum）</h2><ul>\n<li>枚举的定义<br><code>Swift</code>中的枚举是为一组有限种可能性的相关值提供的通用类型（在<code>C</code>/<code>C++</code>/<code>C#</code>中，枚举是一个被命名的整型常数的集合）；使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词<code>enum</code>来定义枚举，并在一对大括号内定义具体内容包括使用<code>case</code>关键字列举成员。就像下面一样：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个表示学生类型的全新枚举类型 StudentType，他有三个成员分别是pupil（小学生，）、middleSchoolStudent（中学生）、collegeStudents（大学生）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StudentType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> pupil</span><br><span class=\"line\">  <span class=\"keyword\">case</span> middleSchoolStudent</span><br><span class=\"line\">  <span class=\"keyword\">case</span> collegeStudent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以读作：如果存在一个<code>StudentType</code>的实例，他要么是<code>pupil</code> （小学生）、要么是<code>middleSchoolStudent</code>（中学生）、要么是<code>collegeStudent</code>（大学生）。注意，和<code>C</code>、o<code>bjective-c</code>中枚举的不同，<code>Swift</code> 中的枚举成员在被创建时不会分配一个默认的整数值。而且不需要给枚举中的每一个成员都提供值(如果你需要也是可以的)。如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型（引自文档翻译）。简单说<code>Swift</code>中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值（不局限于整数类型）。<br>枚举中有两个很容易混淆的概念：原始值(<code>raw value</code>)、关联值(<code>associated value</code>)，两个词听起来比较模糊，下面简单介绍一下：</p>\n<ul>\n<li>枚举的原始值(<code>raw value</code>)<br>枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(<code>raw value</code>)，下面的<code>StudentType</code>中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。注意：<code>Int</code>修饰的是<code>StudentType</code>成员原始值的类型而不是<code>StudentType</code>的类型，<code>StudentType</code>类型从定义开始就是一个全新的枚举类型。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StudentType</span>: <span class=\"title\">Int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> pupil = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> middleSchoolStudent = <span class=\"number\">15</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> collegeStudents = <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好<code>StudentType</code>成员的原始值之后，我们可以使用枚举成员的<code>rawValue</code>属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  常量student1值是 10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student1 = <span class=\"type\">StudentType</span>.pupil.rawValue</span><br><span class=\"line\"><span class=\"comment\">//  变量student2值是 15</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> student2 = <span class=\"type\">StudentType</span>.middleSchoolStudent.rawValue</span><br><span class=\"line\"><span class=\"comment\">//  使用成员rawValue属性创建一个`StudentType`枚举的新实例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student3 = <span class=\"type\">StudentType</span>.<span class=\"keyword\">init</span>(rawValue: <span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"comment\">//  student3的值是 Optional&lt;senson&gt;.Type</span></span><br><span class=\"line\">type(of: student3)</span><br><span class=\"line\"><span class=\"comment\">//  student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student4 = <span class=\"type\">StudentType</span>.<span class=\"keyword\">init</span>(rawValue: <span class=\"number\">30</span>)</span><br></pre></td></tr></table></figure>\n<p>使用原始值初始化器这种方式初始化创建得到<code>StudentType</code>的实例<code>student4</code>是一个<code>StudentType</code>的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在<code>StudentType</code>中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。<br>总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。</p>\n<ul>\n<li>枚举的关联值(<code>associated value</code>)<br>关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudents</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StudentType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> pupil(<span class=\"type\">String</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> middleSchoolStudent(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> collegeStudents(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们并没有为<code>StudentType</code>的成员提供具体的值，而是为他们绑定了不同的类型，分别是<code>pupil</code>绑定<code>String</code>类型、mid<code>dleSchoolStudent</code>和<code>collegeStudents</code>绑定（<code>Int</code>， <code>String</code>）元组类型。接下来就可以创建不同<code>StudentType</code>枚举实例并为对应的成员赋值了。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是\"have fun\"（总是在玩耍）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student1 = <span class=\"type\">StudentType</span>.pupil(<span class=\"string\">\"have fun\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">//student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, \"always study\"（一周7天总是在学习）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student2 = <span class=\"type\">StudentType</span>.middleSchoolStudent(<span class=\"number\">7</span>, <span class=\"string\">\"always study\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">//student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, \"always LOL\"（一周7天总是在撸啊撸）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student3 = <span class=\"type\">StudentType</span>.middleSchoolStudent(<span class=\"number\">7</span>, <span class=\"string\">\"always LOL\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候如果需要判断某个<code>StudentType</code>实例的具体的值就需要这样做了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> student3 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .pupil(<span class=\"keyword\">let</span> things):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"is a pupil and <span class=\"subst\">\\(things)</span>\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .middleSchoolStudent(<span class=\"keyword\">let</span> day, <span class=\"keyword\">let</span> things):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"is a middleSchoolStudent and <span class=\"subst\">\\(day)</span> days <span class=\"subst\">\\(things)</span>\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .collegeStudent(<span class=\"keyword\">let</span> day, <span class=\"keyword\">let</span> things):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"is a collegeStudent and <span class=\"subst\">\\(day)</span> days <span class=\"subst\">\\(things)</span>\"</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。</p>\n<ul>\n<li>递归枚举<br>递归枚举是拥有另一个枚举作为枚举成员关联值的枚举（引自文档翻译）。<br>关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。下面是一个经典的通过递归算法求解n!（阶乘）的函数。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">factorial</span><span class=\"params\">(n: Int)</span></span>-&gt;<span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n: n - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1 * 2 * 3 * 4 * 5 * 6 = 720</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sum = factorial(n: <span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<p>函数<code>factorial (n: int)-&gt; Int</code>在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。</p>\n<h2 id=\"结构体（struct）\"><a href=\"#结构体（struct）\" class=\"headerlink\" title=\"结构体（struct）\"></a>结构体（struct）</h2><ul>\n<li>结构体的定义<br>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在<code>Swift</code>中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。我们通过使用关键词<code>struct</code>来定义结构体。并在一对大括号内定义具体内容包括他的成员和自定义的方法（是的，<code>Swift</code>中的结构体有方法了），定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。废话不多说直接上代码:</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个 Student（学生）类型的结构体用于表示一个学生，Student的成员分别是语、数、外三科`Int`类型的成绩</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里熟悉<code>Swift</code>的同学可能已经发现了一点结构体和类的区别了：定义结构体类型时其成员可以没有初始值。如果使用这种格式定义一个类，编译器是会报错的，他会提醒你这个类没有被初始化。</p>\n<ul>\n<li>结构体实例的创建<br>创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。最简单的语法是在类或结构体名字后面接一个空的圆括号，例如 <code>let student1 = Student()</code>。这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。但是结合上面的代码，由于在定义Student结构体时我们并没有为他的成员赋初值，所以 <code>let student1 = Student()</code>在编译器中报错了，此处报错并不是因为不能这样创建实例而是因为<code>student1</code>成员没有默认值，所以我们可以使用下面的方式创建实例:</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> student2 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">90</span>, math: <span class=\"number\">80</span>, english: <span class=\"number\">70</span>)</span><br></pre></td></tr></table></figure>\n<p>所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义<code>Student</code>时为他的成员赋上初值，那么下面的代码是编译通过的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> student2 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">90</span>, math: <span class=\"number\">80</span>, english: <span class=\"number\">70</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> student4 = <span class=\"type\">Student</span>()</span><br></pre></td></tr></table></figure>\n<p>总结一句：定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。</p>\n<ul>\n<li>自定义的初始化器<br>当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过形如 <code>let student5 = Student(stringScore: &quot;70,80,90&quot;)</code> 的方式创建实例时，就需要自定义初始化方法了：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">      <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">init</span>(chinese: <span class=\"type\">Int</span>, math: <span class=\"type\">Int</span>, english: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chinese = chinese</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.math = math</span><br><span class=\"line\">           <span class=\"keyword\">self</span>.english = english</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">init</span>(stringScore: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">let</span> cme = stringScore.characters.<span class=\"built_in\">split</span>(separator: <span class=\"string\">\",\"</span>)</span><br><span class=\"line\">           chinese = <span class=\"type\">Int</span>(atoi(<span class=\"type\">String</span>(cme.first!)))</span><br><span class=\"line\">           math = <span class=\"type\">Int</span>(atoi(<span class=\"type\">String</span>(cme[<span class=\"number\">1</span>])))</span><br><span class=\"line\">           english = <span class=\"type\">Int</span>(atoi(<span class=\"type\">String</span>(cme.last!)))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> student6 = <span class=\"type\">Student</span>()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> student7 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">90</span>, math: <span class=\"number\">80</span>, english: <span class=\"number\">70</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> student8 = <span class=\"type\">Student</span>(stringScore: <span class=\"string\">\"70,80,90\"</span>)</span><br></pre></td></tr></table></figure>\n<p>一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。</p>\n<ul>\n<li>定义其他方法<br>如果此时需要修改某个学生某科的成绩，该如何实现呢？当然，我们可以定义下面的方法：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更改某个学生某门学科的成绩</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeChinese</span><span class=\"params\">(num: Int, student: <span class=\"keyword\">inout</span> Student)</span></span>&#123;</span><br><span class=\"line\">  student.chinese += num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">changeChinese(num: <span class=\"number\">20</span>, student: &amp;student7)</span><br></pre></td></tr></table></figure>\n<p>此时<code>student7</code>的语文成绩就由原来的<code>90</code>被修改到了<code>110</code>，但是此方法有两个明显的弊端：1，学生的语文成绩<code>chinese</code>是<code>Student</code>结构体的内部成员，一个学生的某科成绩无需被<code>Student</code>的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。2，更改一个学生的语文成绩本身就是和<code>Student</code>结构体内部成员计算相关的事情，我们更希望达到形如：<code>student7.changeChinese(num: 10)</code> 的效果，因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时<code>changeChinese(num:)</code>方法是<code>Student</code>结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chinese: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> math: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> english: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\">   <span class=\"comment\">//修改数学成绩</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeMath</span><span class=\"params\">(num: Int)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.math += num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> student7 = <span class=\"type\">Student</span>(chinese: <span class=\"number\">20</span>, math: <span class=\"number\">30</span>, english: <span class=\"number\">40</span>)</span><br><span class=\"line\">  <span class=\"comment\">//更改分数中语文学科的成绩</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeChinese</span><span class=\"params\">(num: Int, student: <span class=\"keyword\">inout</span> Student)</span></span>&#123;</span><br><span class=\"line\">      student.chinese += num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  changeChinese(num: <span class=\"number\">20</span>, student: &amp;student7)</span><br><span class=\"line\">  student7.changeMath(num: <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为<code>Student</code>结构体内部添加<code>changeMath(num:)</code>的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：<code>mutating</code>关键字。由于结构体是值类型，<code>Swift</code>规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用<code>mutating</code>我们便可以办到这点，当然这也是和类的不同点。</p>\n<ul>\n<li>常见的结构体<br><code>Swift</code>中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示数值类型的结构体：</span></span><br><span class=\"line\">  <span class=\"type\">Int</span>，<span class=\"type\">Float</span>，<span class=\"type\">Double</span>，<span class=\"type\">CGFloat</span>...</span><br><span class=\"line\"><span class=\"comment\">//表示字符和字符串类型的结构体</span></span><br><span class=\"line\">  <span class=\"type\">Character</span>，<span class=\"type\">String</span>...</span><br><span class=\"line\"><span class=\"comment\">//位置和尺寸的结构体</span></span><br><span class=\"line\">  <span class=\"type\">CGPoint</span>，<span class=\"type\">CGSize</span>...</span><br><span class=\"line\"><span class=\"comment\">//集合类型结构体</span></span><br><span class=\"line\">  <span class=\"type\">Array</span>，<span class=\"type\">Set</span>，<span class=\"type\">Dictionary</span>...</span><br></pre></td></tr></table></figure>\n<p>很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Person 类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = <span class=\"string\">\"jack\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> life: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s1 = <span class=\"type\">Person</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s2 = s1</span><br><span class=\"line\">     s2.name = <span class=\"string\">\"mike\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// People 结构体数据结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = <span class=\"string\">\"jack\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> life: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p1 = <span class=\"type\">People</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p2 = p1</span><br><span class=\"line\">      p2.name = <span class=\"string\">\"mike\"</span></span><br></pre></td></tr></table></figure>\n<p>细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是因为 <code>struct</code> 是值引用，<code>class</code> 是类型引用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>枚举、结构体、类的共同点：</p>\n<ul>\n<li>定义属性和方法；</li>\n<li>下标语法访问值；</li>\n<li>初始化器；</li>\n<li>支持扩展增加功能；</li>\n<li>可以遵循协议；</li>\n</ul>\n<p>类特有的功能；</p>\n<ul>\n<li>继承；</li>\n<li>允许类型转换；</li>\n<li>析构方法释放资源；</li>\n<li>引用计数；</li>\n</ul>\n</blockquote>\n<p> 类是引用类型</p>\n<blockquote>\n<p>引用类型(<code>reference types</code>，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。</p>\n</blockquote>\n<p>枚举，结构体是值类型</p>\n<blockquote>\n<p>值类型(<code>value types</code>)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。</p>\n</blockquote>\n<p>该如何选择</p>\n<blockquote>\n<p>关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）：</p>\n<blockquote>\n<p>当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：<br>1.什么时候该用值类型：<br>要用==运算符来比较实例的数据时<br>你希望那个实例的拷贝能保持独立的状态时<br>数据会被多个线程使用时<br>2.什么时候该用引用类型（class）：<br>要用==运算符来比较实例身份的时候<br>你希望有创建一个共享的、可变对象的时候</p>\n</blockquote>\n</blockquote>\n"},{"title":"内存的几大区域","date":"2017-11-17T09:51:33.000Z","_content":"\n## 1. 栈区(stack)\n> 栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］\n\n栈空间分静态分配 和动态分配两种。\n> 静态分配是编译器完成的，比如自动变量(auto)的分配。  \n动态分配由alloca函数完成。  \n栈的动态分配无需释放(是自动的)，也就没有释放函数。  \n为可移植的程序起见，栈的动态分配操作是不被鼓励的。\n\n## 2. 堆区(heap)\n\n\n> 堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。   \n\n优点是灵活方便，数据适应面广泛，但是效率有一定降低。\n\n> 堆是函数库内部数据结构，不一定唯一。  \n不同堆分配的内存无法互相操作。  \n堆的分配总是动态的。\n\n虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。\n\n## 3. 全局区(静态区) (static)\n\n\n> 全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。\n\n> 注意：全局区又可分为**未初始化全局区**(bss段)和**初始化全局区**(data段)  \n 举例:   \n `int a; 未初始化的`  `int a = 10; 初始化的`\n \n\n4. 文字常量区\n------------\n\n > 文字常量区 存放常量字符串，程序结束后由系统释放；\n\n5. 代码区\n------------\n\n> 代码区 存放函数的二进制代码\n\n{% asset_img pic1.jpg 图片来源见水印 %}\n\n\n{% asset_img pic2.jpg 图片来源见水印 %}\n\n\n  \n例子代码：\n{% asset_img pic3.jpg 图片来源见水印 %}\n\n## 可能被追问的问题一：\n\n> * 栈区 (stack [stæk]): \n> 由编译器自动分配释放  \n> 局部变量是保存在栈区的  \n> 方法调用的实参也是保存在栈区的\n\n> * 堆区 (heap [hiːp]):   \n> 由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！\n\n> * BSS 段 :   \n> 程序结束后由系统释放\n\n> * 数据段 :   \n> 程序结束后由系统释放\n\n> * 代码段:  \n> 程序结束后由系统释放\n> 程序编译链接 后的二进制可执行代码\n\n## 可能被追问的问题二：\n\n> * 申请后的系统是如何响应的？\n> > 栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。\n>>\n> > 注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。  \n>>\n>> 堆：  \n>> 1.首先应该知道操作系统有一个记录空闲内存地址的链表。  \n>> 2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。  \n>> 3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中\n\n## 可能被追问的问题三：\n\n> * 申请大小的限制是怎样的？\n> > 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。  \n> > 是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。  \n> > 因此，能从栈获得的空间较小。\n>>\n>> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。  \n>> 这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。  \n>> 堆的大小受限于计算机系统中有效的虚拟内存。  \n>> 由此可见，堆获得的空间比较灵活，也比较大。\n>>\n>> {% asset_img pic4.png 图片来源见水印 %}\n>>  栈：  \n>>  由系统自动分配，速度较快，不会产生内存碎片  \n>>  \n>>  堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便  \n>>  打个比喻来说：  \n>>  使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。  \n>>  使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。\n\n","source":"_posts/内存的几大区域.md","raw":"title: 内存的几大区域\ndate: 2017-11-17 17:51:33\ntags: [内存, iOS]\ncategories: Question\n---\n\n## 1. 栈区(stack)\n> 栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］\n\n栈空间分静态分配 和动态分配两种。\n> 静态分配是编译器完成的，比如自动变量(auto)的分配。  \n动态分配由alloca函数完成。  \n栈的动态分配无需释放(是自动的)，也就没有释放函数。  \n为可移植的程序起见，栈的动态分配操作是不被鼓励的。\n\n## 2. 堆区(heap)\n\n\n> 堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。   \n\n优点是灵活方便，数据适应面广泛，但是效率有一定降低。\n\n> 堆是函数库内部数据结构，不一定唯一。  \n不同堆分配的内存无法互相操作。  \n堆的分配总是动态的。\n\n虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。\n\n## 3. 全局区(静态区) (static)\n\n\n> 全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。\n\n> 注意：全局区又可分为**未初始化全局区**(bss段)和**初始化全局区**(data段)  \n 举例:   \n `int a; 未初始化的`  `int a = 10; 初始化的`\n \n\n4. 文字常量区\n------------\n\n > 文字常量区 存放常量字符串，程序结束后由系统释放；\n\n5. 代码区\n------------\n\n> 代码区 存放函数的二进制代码\n\n{% asset_img pic1.jpg 图片来源见水印 %}\n\n\n{% asset_img pic2.jpg 图片来源见水印 %}\n\n\n  \n例子代码：\n{% asset_img pic3.jpg 图片来源见水印 %}\n\n## 可能被追问的问题一：\n\n> * 栈区 (stack [stæk]): \n> 由编译器自动分配释放  \n> 局部变量是保存在栈区的  \n> 方法调用的实参也是保存在栈区的\n\n> * 堆区 (heap [hiːp]):   \n> 由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！\n\n> * BSS 段 :   \n> 程序结束后由系统释放\n\n> * 数据段 :   \n> 程序结束后由系统释放\n\n> * 代码段:  \n> 程序结束后由系统释放\n> 程序编译链接 后的二进制可执行代码\n\n## 可能被追问的问题二：\n\n> * 申请后的系统是如何响应的？\n> > 栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。\n>>\n> > 注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。  \n>>\n>> 堆：  \n>> 1.首先应该知道操作系统有一个记录空闲内存地址的链表。  \n>> 2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。  \n>> 3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中\n\n## 可能被追问的问题三：\n\n> * 申请大小的限制是怎样的？\n> > 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。  \n> > 是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。  \n> > 因此，能从栈获得的空间较小。\n>>\n>> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。  \n>> 这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。  \n>> 堆的大小受限于计算机系统中有效的虚拟内存。  \n>> 由此可见，堆获得的空间比较灵活，也比较大。\n>>\n>> {% asset_img pic4.png 图片来源见水印 %}\n>>  栈：  \n>>  由系统自动分配，速度较快，不会产生内存碎片  \n>>  \n>>  堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便  \n>>  打个比喻来说：  \n>>  使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。  \n>>  使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。\n\n","slug":"内存的几大区域","published":1,"updated":"2017-11-28T06:34:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz43i0008sku2oo86456l","content":"<h2 id=\"1-栈区-stack\"><a href=\"#1-栈区-stack\" class=\"headerlink\" title=\"1. 栈区(stack)\"></a>1. 栈区(stack)</h2><blockquote>\n<p>栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］</p>\n</blockquote>\n<p>栈空间分静态分配 和动态分配两种。</p>\n<blockquote>\n<p>静态分配是编译器完成的，比如自动变量(auto)的分配。<br>动态分配由alloca函数完成。<br>栈的动态分配无需释放(是自动的)，也就没有释放函数。<br>为可移植的程序起见，栈的动态分配操作是不被鼓励的。</p>\n</blockquote>\n<h2 id=\"2-堆区-heap\"><a href=\"#2-堆区-heap\" class=\"headerlink\" title=\"2. 堆区(heap)\"></a>2. 堆区(heap)</h2><blockquote>\n<p>堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。   </p>\n</blockquote>\n<p>优点是灵活方便，数据适应面广泛，但是效率有一定降低。</p>\n<blockquote>\n<p>堆是函数库内部数据结构，不一定唯一。<br>不同堆分配的内存无法互相操作。<br>堆的分配总是动态的。</p>\n</blockquote>\n<p>虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。</p>\n<h2 id=\"3-全局区-静态区-static\"><a href=\"#3-全局区-静态区-static\" class=\"headerlink\" title=\"3. 全局区(静态区) (static)\"></a>3. 全局区(静态区) (static)</h2><blockquote>\n<p>全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</p>\n<p>注意：全局区又可分为<strong>未初始化全局区</strong>(bss段)和<strong>初始化全局区</strong>(data段)<br> 举例:<br> <code>int a; 未初始化的</code>  <code>int a = 10; 初始化的</code></p>\n</blockquote>\n<h2 id=\"4-文字常量区\"><a href=\"#4-文字常量区\" class=\"headerlink\" title=\"4. 文字常量区\"></a>4. 文字常量区</h2><blockquote>\n<p>文字常量区 存放常量字符串，程序结束后由系统释放；</p>\n</blockquote>\n<h2 id=\"5-代码区\"><a href=\"#5-代码区\" class=\"headerlink\" title=\"5. 代码区\"></a>5. 代码区</h2><blockquote>\n<p>代码区 存放函数的二进制代码</p>\n</blockquote>\n<img src=\"/2017/11/17/内存的几大区域/pic1.jpg\" title=\"图片来源见水印\">\n<img src=\"/2017/11/17/内存的几大区域/pic2.jpg\" title=\"图片来源见水印\">\n<p>例子代码：<br><img src=\"/2017/11/17/内存的几大区域/pic3.jpg\" title=\"图片来源见水印\"></p>\n<h2 id=\"可能被追问的问题一：\"><a href=\"#可能被追问的问题一：\" class=\"headerlink\" title=\"可能被追问的问题一：\"></a>可能被追问的问题一：</h2><blockquote>\n<ul>\n<li><p>栈区 (stack [stæk]):<br>由编译器自动分配释放<br>局部变量是保存在栈区的<br>方法调用的实参也是保存在栈区的</p>\n</li>\n<li><p>堆区 (heap [hiːp]):<br>由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！</p>\n</li>\n<li><p>BSS 段 :<br>程序结束后由系统释放</p>\n</li>\n<li><p>数据段 :<br>程序结束后由系统释放</p>\n</li>\n<li><p>代码段:<br>程序结束后由系统释放<br>程序编译链接 后的二进制可执行代码</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"可能被追问的问题二：\"><a href=\"#可能被追问的问题二：\" class=\"headerlink\" title=\"可能被追问的问题二：\"></a>可能被追问的问题二：</h2><blockquote>\n<ul>\n<li>申请后的系统是如何响应的？<blockquote>\n<p>栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。</p>\n<p>注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。  </p>\n<p>堆：<br>1.首先应该知道操作系统有一个记录空闲内存地址的链表。<br>2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。<br>3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"可能被追问的问题三：\"><a href=\"#可能被追问的问题三：\" class=\"headerlink\" title=\"可能被追问的问题三：\"></a>可能被追问的问题三：</h2><blockquote>\n<ul>\n<li>申请大小的限制是怎样的？<blockquote>\n<p>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br>是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。<br>因此，能从栈获得的空间较小。</p>\n<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。<br>这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。<br>堆的大小受限于计算机系统中有效的虚拟内存。<br>由此可见，堆获得的空间比较灵活，也比较大。</p>\n<img src=\"/2017/11/17/内存的几大区域/pic4.png\" title=\"图片来源见水印\">\n<p> 栈：<br> 由系统自动分配，速度较快，不会产生内存碎片  </p>\n<p> 堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便<br> 打个比喻来说：<br> 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br> 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-栈区-stack\"><a href=\"#1-栈区-stack\" class=\"headerlink\" title=\"1. 栈区(stack)\"></a>1. 栈区(stack)</h2><blockquote>\n<p>栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］</p>\n</blockquote>\n<p>栈空间分静态分配 和动态分配两种。</p>\n<blockquote>\n<p>静态分配是编译器完成的，比如自动变量(auto)的分配。<br>动态分配由alloca函数完成。<br>栈的动态分配无需释放(是自动的)，也就没有释放函数。<br>为可移植的程序起见，栈的动态分配操作是不被鼓励的。</p>\n</blockquote>\n<h2 id=\"2-堆区-heap\"><a href=\"#2-堆区-heap\" class=\"headerlink\" title=\"2. 堆区(heap)\"></a>2. 堆区(heap)</h2><blockquote>\n<p>堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。   </p>\n</blockquote>\n<p>优点是灵活方便，数据适应面广泛，但是效率有一定降低。</p>\n<blockquote>\n<p>堆是函数库内部数据结构，不一定唯一。<br>不同堆分配的内存无法互相操作。<br>堆的分配总是动态的。</p>\n</blockquote>\n<p>虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。</p>\n<h2 id=\"3-全局区-静态区-static\"><a href=\"#3-全局区-静态区-static\" class=\"headerlink\" title=\"3. 全局区(静态区) (static)\"></a>3. 全局区(静态区) (static)</h2><blockquote>\n<p>全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</p>\n<p>注意：全局区又可分为<strong>未初始化全局区</strong>(bss段)和<strong>初始化全局区</strong>(data段)<br> 举例:<br> <code>int a; 未初始化的</code>  <code>int a = 10; 初始化的</code></p>\n</blockquote>\n<h2 id=\"4-文字常量区\"><a href=\"#4-文字常量区\" class=\"headerlink\" title=\"4. 文字常量区\"></a>4. 文字常量区</h2><blockquote>\n<p>文字常量区 存放常量字符串，程序结束后由系统释放；</p>\n</blockquote>\n<h2 id=\"5-代码区\"><a href=\"#5-代码区\" class=\"headerlink\" title=\"5. 代码区\"></a>5. 代码区</h2><blockquote>\n<p>代码区 存放函数的二进制代码</p>\n</blockquote>\n<img src=\"/2017/11/17/内存的几大区域/pic1.jpg\" title=\"图片来源见水印\">\n<img src=\"/2017/11/17/内存的几大区域/pic2.jpg\" title=\"图片来源见水印\">\n<p>例子代码：<br><img src=\"/2017/11/17/内存的几大区域/pic3.jpg\" title=\"图片来源见水印\"></p>\n<h2 id=\"可能被追问的问题一：\"><a href=\"#可能被追问的问题一：\" class=\"headerlink\" title=\"可能被追问的问题一：\"></a>可能被追问的问题一：</h2><blockquote>\n<ul>\n<li><p>栈区 (stack [stæk]):<br>由编译器自动分配释放<br>局部变量是保存在栈区的<br>方法调用的实参也是保存在栈区的</p>\n</li>\n<li><p>堆区 (heap [hiːp]):<br>由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！</p>\n</li>\n<li><p>BSS 段 :<br>程序结束后由系统释放</p>\n</li>\n<li><p>数据段 :<br>程序结束后由系统释放</p>\n</li>\n<li><p>代码段:<br>程序结束后由系统释放<br>程序编译链接 后的二进制可执行代码</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"可能被追问的问题二：\"><a href=\"#可能被追问的问题二：\" class=\"headerlink\" title=\"可能被追问的问题二：\"></a>可能被追问的问题二：</h2><blockquote>\n<ul>\n<li>申请后的系统是如何响应的？<blockquote>\n<p>栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。</p>\n<p>注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。  </p>\n<p>堆：<br>1.首先应该知道操作系统有一个记录空闲内存地址的链表。<br>2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。<br>3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"可能被追问的问题三：\"><a href=\"#可能被追问的问题三：\" class=\"headerlink\" title=\"可能被追问的问题三：\"></a>可能被追问的问题三：</h2><blockquote>\n<ul>\n<li>申请大小的限制是怎样的？<blockquote>\n<p>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br>是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。<br>因此，能从栈获得的空间较小。</p>\n<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。<br>这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。<br>堆的大小受限于计算机系统中有效的虚拟内存。<br>由此可见，堆获得的空间比较灵活，也比较大。</p>\n<img src=\"/2017/11/17/内存的几大区域/pic4.png\" title=\"图片来源见水印\">\n<p> 栈：<br> 由系统自动分配，速度较快，不会产生内存碎片  </p>\n<p> 堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便<br> 打个比喻来说：<br> 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br> 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n"},{"title":"如何分析App内存","date":"2017-11-18T03:33:39.000Z","_content":"\n> Xcode下查看app内存使用情况有2种方法：\n\n> - Navigator导航栏中的Debug navigator中的Memory\n\n> - Instruments\n\n 1. Debug navigator中的Memory\n-----------------------\n\n此方法是查看内存最简单直接有效的方法，真机调试时，通过Debug navigator中Memory查看app内存，入口如图\n\n{% asset_img pic1.jpeg 图片来源见水印 %}\n\n根据这个值查看app内存占用，这个内存是当前app占用的总内存，是堆栈内存、虚拟内存（OpenGL占用的显存算在虚拟内存中里面）的总和。\n\n2. Instruments\n-----------------------\n\n启动Instruments的方法是，Product->Profile，经过漫长的编译时间后，出现Instruments界面，如下图\n\n{% asset_img pic2.jpeg 图片来源见水印 %}\n\nInstruments中，可以分析内存的工具有Activity Monitor、Allocations、Leaks。\n\n> **Leaks**\nLeaks是检测内存泄露的工具，很有用。Leaks运行中，看到下面这个红叉叉就表示有内存泄露了\n\n> {% asset_img pic3.jpeg 图片来源见水印 %}  \n\n\n----------\n\n\n> **Allocations**\nAllocations是检测堆栈内存的，下面的VM tracker检测虚拟内存。Allocations运行起来如下图\n\n> {% asset_img pic4.jpeg 图片来源见水印 %}\n\n> Allocations永远比Debug navigator Memory中显示的内存要小，就是因为Allocations中没有统计虚拟内存。\n下图参考：\n{% asset_img pic5.jpeg 图片来源见水印 %}\n\n> 部分malloc出来的内存也算在虚拟内存中，下图参考自A look at how malloc works on the Mac\n{% asset_img pic6.jpeg 图片来源见水印 %}\n\n\n----------\n\n> **Activity monitor**\nActivity monitor看手机整体内存情况的，这里的显示app内存值和Debug navigator中的Memory显示的值是一样的\n{% asset_img pic7.jpeg 图片来源见水印 %}\n\n\n----------\n\n> 其他\n> --\n\n> - App最多能占用多少内存不闪退\n>> 占用机器内存的一半左右就会闪退，和系统版本、后台程序数有关。\n{% asset_img pic8.jpeg 图片来源见水印 %}\n不同渠道对内存有不同的要求，例如如下某渠道\n{% asset_img pic9.jpeg 图片来源见水印 %}\n\n> - iOS的App为什么内存没有泄露，内存却降不下来\n>>  eg: 创建大概20个哥布林spine动画，此时内存占用46M，然后释放掉，内存占用竟然还是46M，以为是spine有内存泄露，Leaks检测没有发现内存泄露。反复加载释放20个哥布林，内存都没有超过48M，但是为毛内存没有下降，而是维持在46M左右\n{% asset_img pic10.jpeg 图片来源见水印 %}\n因为  \n（1）图片加入了TextureCache，占用了部分内存  \n（2）malloc出来的一部分内存算到了VM（虚拟内存）中，为了下次malloc速度更快，这部分内存虽然调用了free，但iOS系统依然没有将其回收。这就是上面说的部分malloc出来的内存也算在虚拟内存中。","source":"_posts/如何分析App内存.md","raw":"---\ntitle: 如何分析App内存\ndate: 2017-11-18 11:33:39\ntags: [iOS, Xcode, Instruments, 内存]\ncategories: Question\n\n---\n\n> Xcode下查看app内存使用情况有2种方法：\n\n> - Navigator导航栏中的Debug navigator中的Memory\n\n> - Instruments\n\n 1. Debug navigator中的Memory\n-----------------------\n\n此方法是查看内存最简单直接有效的方法，真机调试时，通过Debug navigator中Memory查看app内存，入口如图\n\n{% asset_img pic1.jpeg 图片来源见水印 %}\n\n根据这个值查看app内存占用，这个内存是当前app占用的总内存，是堆栈内存、虚拟内存（OpenGL占用的显存算在虚拟内存中里面）的总和。\n\n2. Instruments\n-----------------------\n\n启动Instruments的方法是，Product->Profile，经过漫长的编译时间后，出现Instruments界面，如下图\n\n{% asset_img pic2.jpeg 图片来源见水印 %}\n\nInstruments中，可以分析内存的工具有Activity Monitor、Allocations、Leaks。\n\n> **Leaks**\nLeaks是检测内存泄露的工具，很有用。Leaks运行中，看到下面这个红叉叉就表示有内存泄露了\n\n> {% asset_img pic3.jpeg 图片来源见水印 %}  \n\n\n----------\n\n\n> **Allocations**\nAllocations是检测堆栈内存的，下面的VM tracker检测虚拟内存。Allocations运行起来如下图\n\n> {% asset_img pic4.jpeg 图片来源见水印 %}\n\n> Allocations永远比Debug navigator Memory中显示的内存要小，就是因为Allocations中没有统计虚拟内存。\n下图参考：\n{% asset_img pic5.jpeg 图片来源见水印 %}\n\n> 部分malloc出来的内存也算在虚拟内存中，下图参考自A look at how malloc works on the Mac\n{% asset_img pic6.jpeg 图片来源见水印 %}\n\n\n----------\n\n> **Activity monitor**\nActivity monitor看手机整体内存情况的，这里的显示app内存值和Debug navigator中的Memory显示的值是一样的\n{% asset_img pic7.jpeg 图片来源见水印 %}\n\n\n----------\n\n> 其他\n> --\n\n> - App最多能占用多少内存不闪退\n>> 占用机器内存的一半左右就会闪退，和系统版本、后台程序数有关。\n{% asset_img pic8.jpeg 图片来源见水印 %}\n不同渠道对内存有不同的要求，例如如下某渠道\n{% asset_img pic9.jpeg 图片来源见水印 %}\n\n> - iOS的App为什么内存没有泄露，内存却降不下来\n>>  eg: 创建大概20个哥布林spine动画，此时内存占用46M，然后释放掉，内存占用竟然还是46M，以为是spine有内存泄露，Leaks检测没有发现内存泄露。反复加载释放20个哥布林，内存都没有超过48M，但是为毛内存没有下降，而是维持在46M左右\n{% asset_img pic10.jpeg 图片来源见水印 %}\n因为  \n（1）图片加入了TextureCache，占用了部分内存  \n（2）malloc出来的一部分内存算到了VM（虚拟内存）中，为了下次malloc速度更快，这部分内存虽然调用了free，但iOS系统依然没有将其回收。这就是上面说的部分malloc出来的内存也算在虚拟内存中。","slug":"如何分析App内存","published":1,"updated":"2017-11-28T10:14:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz43l000bsku28c4g0og2","content":"<blockquote>\n<p>Xcode下查看app内存使用情况有2种方法：</p>\n<ul>\n<li><p>Navigator导航栏中的Debug navigator中的Memory</p>\n</li>\n<li><p>Instruments</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"1-Debug-navigator中的Memory\"><a href=\"#1-Debug-navigator中的Memory\" class=\"headerlink\" title=\" 1. Debug navigator中的Memory\"></a> 1. Debug navigator中的Memory</h2><p>此方法是查看内存最简单直接有效的方法，真机调试时，通过Debug navigator中Memory查看app内存，入口如图</p>\n<img src=\"/2017/11/18/如何分析App内存/pic1.jpeg\" title=\"图片来源见水印\">\n<p>根据这个值查看app内存占用，这个内存是当前app占用的总内存，是堆栈内存、虚拟内存（OpenGL占用的显存算在虚拟内存中里面）的总和。</p>\n<h2 id=\"2-Instruments\"><a href=\"#2-Instruments\" class=\"headerlink\" title=\"2. Instruments\"></a>2. Instruments</h2><p>启动Instruments的方法是，Product-&gt;Profile，经过漫长的编译时间后，出现Instruments界面，如下图</p>\n<img src=\"/2017/11/18/如何分析App内存/pic2.jpeg\" title=\"图片来源见水印\">\n<p>Instruments中，可以分析内存的工具有Activity Monitor、Allocations、Leaks。</p>\n<blockquote>\n<p><strong>Leaks</strong><br>Leaks是检测内存泄露的工具，很有用。Leaks运行中，看到下面这个红叉叉就表示有内存泄露了</p>\n<img src=\"/2017/11/18/如何分析App内存/pic3.jpeg\" title=\"图片来源见水印\">  \n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Allocations</strong><br>Allocations是检测堆栈内存的，下面的VM tracker检测虚拟内存。Allocations运行起来如下图</p>\n<img src=\"/2017/11/18/如何分析App内存/pic4.jpeg\" title=\"图片来源见水印\">\n<p>Allocations永远比Debug navigator Memory中显示的内存要小，就是因为Allocations中没有统计虚拟内存。<br>下图参考：<br><img src=\"/2017/11/18/如何分析App内存/pic5.jpeg\" title=\"图片来源见水印\"></p>\n<p>部分malloc出来的内存也算在虚拟内存中，下图参考自A look at how malloc works on the Mac<br><img src=\"/2017/11/18/如何分析App内存/pic6.jpeg\" title=\"图片来源见水印\"></p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Activity monitor</strong><br>Activity monitor看手机整体内存情况的，这里的显示app内存值和Debug navigator中的Memory显示的值是一样的<br><img src=\"/2017/11/18/如何分析App内存/pic7.jpeg\" title=\"图片来源见水印\"></p>\n</blockquote>\n<hr>\n<blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><p>App最多能占用多少内存不闪退</p>\n<blockquote>\n<p>占用机器内存的一半左右就会闪退，和系统版本、后台程序数有关。</p>\n<img src=\"/2017/11/18/如何分析App内存/pic8.jpeg\" title=\"图片来源见水印\">\n<p>不同渠道对内存有不同的要求，例如如下某渠道</p>\n<img src=\"/2017/11/18/如何分析App内存/pic9.jpeg\" title=\"图片来源见水印\">\n</blockquote>\n</li>\n<li><p>iOS的App为什么内存没有泄露，内存却降不下来</p>\n<blockquote>\n<p> eg: 创建大概20个哥布林spine动画，此时内存占用46M，然后释放掉，内存占用竟然还是46M，以为是spine有内存泄露，Leaks检测没有发现内存泄露。反复加载释放20个哥布林，内存都没有超过48M，但是为毛内存没有下降，而是维持在46M左右</p>\n<img src=\"/2017/11/18/如何分析App内存/pic10.jpeg\" title=\"图片来源见水印\">\n<p>因为<br>（1）图片加入了TextureCache，占用了部分内存<br>（2）malloc出来的一部分内存算到了VM（虚拟内存）中，为了下次malloc速度更快，这部分内存虽然调用了free，但iOS系统依然没有将其回收。这就是上面说的部分malloc出来的内存也算在虚拟内存中。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Xcode下查看app内存使用情况有2种方法：</p>\n<ul>\n<li><p>Navigator导航栏中的Debug navigator中的Memory</p>\n</li>\n<li><p>Instruments</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"1-Debug-navigator中的Memory\"><a href=\"#1-Debug-navigator中的Memory\" class=\"headerlink\" title=\" 1. Debug navigator中的Memory\"></a> 1. Debug navigator中的Memory</h2><p>此方法是查看内存最简单直接有效的方法，真机调试时，通过Debug navigator中Memory查看app内存，入口如图</p>\n<img src=\"/2017/11/18/如何分析App内存/pic1.jpeg\" title=\"图片来源见水印\">\n<p>根据这个值查看app内存占用，这个内存是当前app占用的总内存，是堆栈内存、虚拟内存（OpenGL占用的显存算在虚拟内存中里面）的总和。</p>\n<h2 id=\"2-Instruments\"><a href=\"#2-Instruments\" class=\"headerlink\" title=\"2. Instruments\"></a>2. Instruments</h2><p>启动Instruments的方法是，Product-&gt;Profile，经过漫长的编译时间后，出现Instruments界面，如下图</p>\n<img src=\"/2017/11/18/如何分析App内存/pic2.jpeg\" title=\"图片来源见水印\">\n<p>Instruments中，可以分析内存的工具有Activity Monitor、Allocations、Leaks。</p>\n<blockquote>\n<p><strong>Leaks</strong><br>Leaks是检测内存泄露的工具，很有用。Leaks运行中，看到下面这个红叉叉就表示有内存泄露了</p>\n<img src=\"/2017/11/18/如何分析App内存/pic3.jpeg\" title=\"图片来源见水印\">  \n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Allocations</strong><br>Allocations是检测堆栈内存的，下面的VM tracker检测虚拟内存。Allocations运行起来如下图</p>\n<img src=\"/2017/11/18/如何分析App内存/pic4.jpeg\" title=\"图片来源见水印\">\n<p>Allocations永远比Debug navigator Memory中显示的内存要小，就是因为Allocations中没有统计虚拟内存。<br>下图参考：<br><img src=\"/2017/11/18/如何分析App内存/pic5.jpeg\" title=\"图片来源见水印\"></p>\n<p>部分malloc出来的内存也算在虚拟内存中，下图参考自A look at how malloc works on the Mac<br><img src=\"/2017/11/18/如何分析App内存/pic6.jpeg\" title=\"图片来源见水印\"></p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Activity monitor</strong><br>Activity monitor看手机整体内存情况的，这里的显示app内存值和Debug navigator中的Memory显示的值是一样的<br><img src=\"/2017/11/18/如何分析App内存/pic7.jpeg\" title=\"图片来源见水印\"></p>\n</blockquote>\n<hr>\n<blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><p>App最多能占用多少内存不闪退</p>\n<blockquote>\n<p>占用机器内存的一半左右就会闪退，和系统版本、后台程序数有关。</p>\n<img src=\"/2017/11/18/如何分析App内存/pic8.jpeg\" title=\"图片来源见水印\">\n<p>不同渠道对内存有不同的要求，例如如下某渠道</p>\n<img src=\"/2017/11/18/如何分析App内存/pic9.jpeg\" title=\"图片来源见水印\">\n</blockquote>\n</li>\n<li><p>iOS的App为什么内存没有泄露，内存却降不下来</p>\n<blockquote>\n<p> eg: 创建大概20个哥布林spine动画，此时内存占用46M，然后释放掉，内存占用竟然还是46M，以为是spine有内存泄露，Leaks检测没有发现内存泄露。反复加载释放20个哥布林，内存都没有超过48M，但是为毛内存没有下降，而是维持在46M左右</p>\n<img src=\"/2017/11/18/如何分析App内存/pic10.jpeg\" title=\"图片来源见水印\">\n<p>因为<br>（1）图片加入了TextureCache，占用了部分内存<br>（2）malloc出来的一部分内存算到了VM（虚拟内存）中，为了下次malloc速度更快，这部分内存虽然调用了free，但iOS系统依然没有将其回收。这就是上面说的部分malloc出来的内存也算在虚拟内存中。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n"},{"title":"解决 TableView 滑动卡顿","date":"2017-11-23T06:14:27.000Z","_content":"\n 1. **最常用的就是cell的重用， 注册重用标识符**\n----------\n> 如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell\n>\n如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID\n>\n每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell\n\n 2. **避免cell的重新布局**\n----------\n> cell的布局填充等操作 比较耗时，一般创建时就布局好\n可以将cell单独放到一个自定义类，在初始化时就布局好\n\n 3. **提前计算并缓存cell的属性及内容**\n----------\n> 当我们创建cell的数据源方法时，编译器并不是先创建cell 再确定cell的高度  \n而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell\n\n 4. **减少cell中控件的数量**\n----------\n> 尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，不使用的可以先隐藏\n\n 5. **不要使用ClearColor，无背景色，透明度也不要设置为0**\n----------\n> 因为这样渲染耗时比较长\n\n 6. **使用局部更新**\n----------\n> 如果只是更新某组的话，使用reloadSection进行局部更新\n\n 7. **加载网络数据，下载图片，使用异步加载，并对图片进行缓存**\n---------- \n 8. **尽量避免addView 给cell动态添加view**\n----------\n> 避免过多的消耗性能\n\n 9. **按需加载cell，cell滚动很快时，只加载范围内的cell**\n----------\n 10. **不要实现无用的代理方法，tableView只遵守两个协议**\n---------- \n 11. **缓存行高**\n----------\n> estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可\n\n**小结**\n----------\n\n> 有了上面的方法，我们在优化tableView的时候就能很好解决卡顿的问题了。\n在iOS应用中，UITableView应该是使用率最高的视图之一了。  \niPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、\nSafari、App Store、iTunes、Game Center…几乎所有自带的应用中都能看到它的身影，可见它的重要性。  \n然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。  \n实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看 LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。\n\n \n","source":"_posts/解决-TableView-滑动卡顿.md","raw":"---\ntitle: 解决 TableView 滑动卡顿\ndate: 2017-11-23 14:14:27\ntags: [iOS, TableView, 优化]\ncategories: Question\n\n---\n\n 1. **最常用的就是cell的重用， 注册重用标识符**\n----------\n> 如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell\n>\n如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID\n>\n每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell\n\n 2. **避免cell的重新布局**\n----------\n> cell的布局填充等操作 比较耗时，一般创建时就布局好\n可以将cell单独放到一个自定义类，在初始化时就布局好\n\n 3. **提前计算并缓存cell的属性及内容**\n----------\n> 当我们创建cell的数据源方法时，编译器并不是先创建cell 再确定cell的高度  \n而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell\n\n 4. **减少cell中控件的数量**\n----------\n> 尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，不使用的可以先隐藏\n\n 5. **不要使用ClearColor，无背景色，透明度也不要设置为0**\n----------\n> 因为这样渲染耗时比较长\n\n 6. **使用局部更新**\n----------\n> 如果只是更新某组的话，使用reloadSection进行局部更新\n\n 7. **加载网络数据，下载图片，使用异步加载，并对图片进行缓存**\n---------- \n 8. **尽量避免addView 给cell动态添加view**\n----------\n> 避免过多的消耗性能\n\n 9. **按需加载cell，cell滚动很快时，只加载范围内的cell**\n----------\n 10. **不要实现无用的代理方法，tableView只遵守两个协议**\n---------- \n 11. **缓存行高**\n----------\n> estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可\n\n**小结**\n----------\n\n> 有了上面的方法，我们在优化tableView的时候就能很好解决卡顿的问题了。\n在iOS应用中，UITableView应该是使用率最高的视图之一了。  \niPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、\nSafari、App Store、iTunes、Game Center…几乎所有自带的应用中都能看到它的身影，可见它的重要性。  \n然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。  \n实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看 LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。\n\n \n","slug":"解决-TableView-滑动卡顿","published":1,"updated":"2017-11-28T10:15:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaoxz43n000csku2rxmm269y","content":"<h2 id=\"1-最常用的就是cell的重用，-注册重用标识符\"><a href=\"#1-最常用的就是cell的重用，-注册重用标识符\" class=\"headerlink\" title=\" 1. 最常用的就是cell的重用， 注册重用标识符\"></a> 1. <strong>最常用的就是cell的重用， 注册重用标识符</strong></h2><blockquote>\n<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</p>\n<p>如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID</p>\n<p>每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</p>\n</blockquote>\n<h2 id=\"2-避免cell的重新布局\"><a href=\"#2-避免cell的重新布局\" class=\"headerlink\" title=\" 2. 避免cell的重新布局\"></a> 2. <strong>避免cell的重新布局</strong></h2><blockquote>\n<p>cell的布局填充等操作 比较耗时，一般创建时就布局好<br>可以将cell单独放到一个自定义类，在初始化时就布局好</p>\n</blockquote>\n<h2 id=\"3-提前计算并缓存cell的属性及内容\"><a href=\"#3-提前计算并缓存cell的属性及内容\" class=\"headerlink\" title=\" 3. 提前计算并缓存cell的属性及内容\"></a> 3. <strong>提前计算并缓存cell的属性及内容</strong></h2><blockquote>\n<p>当我们创建cell的数据源方法时，编译器并不是先创建cell 再确定cell的高度<br>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>\n</blockquote>\n<h2 id=\"4-减少cell中控件的数量\"><a href=\"#4-减少cell中控件的数量\" class=\"headerlink\" title=\" 4. 减少cell中控件的数量\"></a> 4. <strong>减少cell中控件的数量</strong></h2><blockquote>\n<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，不使用的可以先隐藏</p>\n</blockquote>\n<h2 id=\"5-不要使用ClearColor，无背景色，透明度也不要设置为0\"><a href=\"#5-不要使用ClearColor，无背景色，透明度也不要设置为0\" class=\"headerlink\" title=\" 5. 不要使用ClearColor，无背景色，透明度也不要设置为0\"></a> 5. <strong>不要使用ClearColor，无背景色，透明度也不要设置为0</strong></h2><blockquote>\n<p>因为这样渲染耗时比较长</p>\n</blockquote>\n<h2 id=\"6-使用局部更新\"><a href=\"#6-使用局部更新\" class=\"headerlink\" title=\" 6. 使用局部更新\"></a> 6. <strong>使用局部更新</strong></h2><blockquote>\n<p>如果只是更新某组的话，使用reloadSection进行局部更新</p>\n</blockquote>\n<h2 id=\"7-加载网络数据，下载图片，使用异步加载，并对图片进行缓存\"><a href=\"#7-加载网络数据，下载图片，使用异步加载，并对图片进行缓存\" class=\"headerlink\" title=\" 7. 加载网络数据，下载图片，使用异步加载，并对图片进行缓存\"></a> 7. <strong>加载网络数据，下载图片，使用异步加载，并对图片进行缓存</strong></h2><h2 id=\"8-尽量避免addView-给cell动态添加view\"><a href=\"#8-尽量避免addView-给cell动态添加view\" class=\"headerlink\" title=\" 8. 尽量避免addView 给cell动态添加view\"></a> 8. <strong>尽量避免addView 给cell动态添加view</strong></h2><blockquote>\n<p>避免过多的消耗性能</p>\n</blockquote>\n<h2 id=\"9-按需加载cell，cell滚动很快时，只加载范围内的cell\"><a href=\"#9-按需加载cell，cell滚动很快时，只加载范围内的cell\" class=\"headerlink\" title=\" 9. 按需加载cell，cell滚动很快时，只加载范围内的cell\"></a> 9. <strong>按需加载cell，cell滚动很快时，只加载范围内的cell</strong></h2><h2 id=\"10-不要实现无用的代理方法，tableView只遵守两个协议\"><a href=\"#10-不要实现无用的代理方法，tableView只遵守两个协议\" class=\"headerlink\" title=\" 10. 不要实现无用的代理方法，tableView只遵守两个协议\"></a> 10. <strong>不要实现无用的代理方法，tableView只遵守两个协议</strong></h2><h2 id=\"11-缓存行高\"><a href=\"#11-缓存行高\" class=\"headerlink\" title=\" 11. 缓存行高\"></a> 11. <strong>缓存行高</strong></h2><blockquote>\n<p>estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><blockquote>\n<p>有了上面的方法，我们在优化tableView的时候就能很好解决卡顿的问题了。<br>在iOS应用中，UITableView应该是使用率最高的视图之一了。<br>iPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、<br>Safari、App Store、iTunes、Game Center…几乎所有自带的应用中都能看到它的身影，可见它的重要性。<br>然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。<br>实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看 LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-最常用的就是cell的重用，-注册重用标识符\"><a href=\"#1-最常用的就是cell的重用，-注册重用标识符\" class=\"headerlink\" title=\" 1. 最常用的就是cell的重用， 注册重用标识符\"></a> 1. <strong>最常用的就是cell的重用， 注册重用标识符</strong></h2><blockquote>\n<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</p>\n<p>如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID</p>\n<p>每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</p>\n</blockquote>\n<h2 id=\"2-避免cell的重新布局\"><a href=\"#2-避免cell的重新布局\" class=\"headerlink\" title=\" 2. 避免cell的重新布局\"></a> 2. <strong>避免cell的重新布局</strong></h2><blockquote>\n<p>cell的布局填充等操作 比较耗时，一般创建时就布局好<br>可以将cell单独放到一个自定义类，在初始化时就布局好</p>\n</blockquote>\n<h2 id=\"3-提前计算并缓存cell的属性及内容\"><a href=\"#3-提前计算并缓存cell的属性及内容\" class=\"headerlink\" title=\" 3. 提前计算并缓存cell的属性及内容\"></a> 3. <strong>提前计算并缓存cell的属性及内容</strong></h2><blockquote>\n<p>当我们创建cell的数据源方法时，编译器并不是先创建cell 再确定cell的高度<br>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>\n</blockquote>\n<h2 id=\"4-减少cell中控件的数量\"><a href=\"#4-减少cell中控件的数量\" class=\"headerlink\" title=\" 4. 减少cell中控件的数量\"></a> 4. <strong>减少cell中控件的数量</strong></h2><blockquote>\n<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，不使用的可以先隐藏</p>\n</blockquote>\n<h2 id=\"5-不要使用ClearColor，无背景色，透明度也不要设置为0\"><a href=\"#5-不要使用ClearColor，无背景色，透明度也不要设置为0\" class=\"headerlink\" title=\" 5. 不要使用ClearColor，无背景色，透明度也不要设置为0\"></a> 5. <strong>不要使用ClearColor，无背景色，透明度也不要设置为0</strong></h2><blockquote>\n<p>因为这样渲染耗时比较长</p>\n</blockquote>\n<h2 id=\"6-使用局部更新\"><a href=\"#6-使用局部更新\" class=\"headerlink\" title=\" 6. 使用局部更新\"></a> 6. <strong>使用局部更新</strong></h2><blockquote>\n<p>如果只是更新某组的话，使用reloadSection进行局部更新</p>\n</blockquote>\n<h2 id=\"7-加载网络数据，下载图片，使用异步加载，并对图片进行缓存\"><a href=\"#7-加载网络数据，下载图片，使用异步加载，并对图片进行缓存\" class=\"headerlink\" title=\" 7. 加载网络数据，下载图片，使用异步加载，并对图片进行缓存\"></a> 7. <strong>加载网络数据，下载图片，使用异步加载，并对图片进行缓存</strong></h2><h2 id=\"8-尽量避免addView-给cell动态添加view\"><a href=\"#8-尽量避免addView-给cell动态添加view\" class=\"headerlink\" title=\" 8. 尽量避免addView 给cell动态添加view\"></a> 8. <strong>尽量避免addView 给cell动态添加view</strong></h2><blockquote>\n<p>避免过多的消耗性能</p>\n</blockquote>\n<h2 id=\"9-按需加载cell，cell滚动很快时，只加载范围内的cell\"><a href=\"#9-按需加载cell，cell滚动很快时，只加载范围内的cell\" class=\"headerlink\" title=\" 9. 按需加载cell，cell滚动很快时，只加载范围内的cell\"></a> 9. <strong>按需加载cell，cell滚动很快时，只加载范围内的cell</strong></h2><h2 id=\"10-不要实现无用的代理方法，tableView只遵守两个协议\"><a href=\"#10-不要实现无用的代理方法，tableView只遵守两个协议\" class=\"headerlink\" title=\" 10. 不要实现无用的代理方法，tableView只遵守两个协议\"></a> 10. <strong>不要实现无用的代理方法，tableView只遵守两个协议</strong></h2><h2 id=\"11-缓存行高\"><a href=\"#11-缓存行高\" class=\"headerlink\" title=\" 11. 缓存行高\"></a> 11. <strong>缓存行高</strong></h2><blockquote>\n<p>estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><blockquote>\n<p>有了上面的方法，我们在优化tableView的时候就能很好解决卡顿的问题了。<br>在iOS应用中，UITableView应该是使用率最高的视图之一了。<br>iPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、<br>Safari、App Store、iTunes、Game Center…几乎所有自带的应用中都能看到它的身影，可见它的重要性。<br>然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。<br>实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看 LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。</p>\n</blockquote>\n"}],"PostAsset":[{"_id":"source/_posts/block本质是什么/pic1.jpeg","post":"cjaoxz43f0006sku2gun935os","slug":"pic1.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/内存的几大区域/pic1.jpg","post":"cjaoxz43i0008sku2oo86456l","slug":"pic1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/内存的几大区域/pic2.jpg","post":"cjaoxz43i0008sku2oo86456l","slug":"pic2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/内存的几大区域/pic3.jpg","post":"cjaoxz43i0008sku2oo86456l","slug":"pic3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/内存的几大区域/pic4.png","post":"cjaoxz43i0008sku2oo86456l","slug":"pic4.png","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic1.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic1.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic10.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic10.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic2.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic2.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic3.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic3.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic4.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic4.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic5.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic5.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic6.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic6.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic7.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic7.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic8.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic8.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/如何分析App内存/pic9.jpeg","post":"cjaoxz43l000bsku28c4g0og2","slug":"pic9.jpeg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjaoxz4350000sku2aq0t9sq3","category_id":"cjaoxz43d0004sku27m8sh4a0","_id":"cjaoxz43o000esku2hyp9vcrb"},{"post_id":"cjaoxz43i0008sku2oo86456l","category_id":"cjaoxz43d0004sku27m8sh4a0","_id":"cjaoxz43p000gsku2sitbkzsp"},{"post_id":"cjaoxz43l000bsku28c4g0og2","category_id":"cjaoxz43d0004sku27m8sh4a0","_id":"cjaoxz43s000jsku28axiage3"},{"post_id":"cjaoxz43a0002sku2kevm3go9","category_id":"cjaoxz43d0004sku27m8sh4a0","_id":"cjaoxz43s000msku27a1bfzby"},{"post_id":"cjaoxz43n000csku2rxmm269y","category_id":"cjaoxz43d0004sku27m8sh4a0","_id":"cjaoxz43t000nsku2hfs5pu4r"},{"post_id":"cjaoxz43f0006sku2gun935os","category_id":"cjaoxz43d0004sku27m8sh4a0","_id":"cjaoxz43t000psku2vtvwlmch"},{"post_id":"cjaoxz43h0007sku2vgzgkks7","category_id":"cjaoxz43r000isku280bo23jp","_id":"cjaoxz43u000rsku26bxgkv0d"}],"PostTag":[{"post_id":"cjaoxz4350000sku2aq0t9sq3","tag_id":"cjaoxz43f0005sku28empxqqf","_id":"cjaoxz43q000hsku2s6mrmvpb"},{"post_id":"cjaoxz4350000sku2aq0t9sq3","tag_id":"cjaoxz43i000asku2ciaoslab","_id":"cjaoxz43s000ksku2z9d9gjrr"},{"post_id":"cjaoxz43a0002sku2kevm3go9","tag_id":"cjaoxz43f0005sku28empxqqf","_id":"cjaoxz43u000qsku2j3r82ia0"},{"post_id":"cjaoxz43a0002sku2kevm3go9","tag_id":"cjaoxz43s000lsku2g095jocz","_id":"cjaoxz43u000ssku2tw75zt16"},{"post_id":"cjaoxz43f0006sku2gun935os","tag_id":"cjaoxz43f0005sku28empxqqf","_id":"cjaoxz43v000vsku23b7mziiw"},{"post_id":"cjaoxz43f0006sku2gun935os","tag_id":"cjaoxz43u000tsku2b51avfy7","_id":"cjaoxz43w000wsku2yxh6dgw2"},{"post_id":"cjaoxz43h0007sku2vgzgkks7","tag_id":"cjaoxz43v000usku2vo9wattc","_id":"cjaoxz43y0011sku21trh8hbg"},{"post_id":"cjaoxz43h0007sku2vgzgkks7","tag_id":"cjaoxz43w000xsku2ntpl7u2d","_id":"cjaoxz43y0012sku2gv8gluu7"},{"post_id":"cjaoxz43h0007sku2vgzgkks7","tag_id":"cjaoxz43x000ysku27gzab7fr","_id":"cjaoxz43y0014sku24l6ijcib"},{"post_id":"cjaoxz43h0007sku2vgzgkks7","tag_id":"cjaoxz43x000zsku2tt7eqbqm","_id":"cjaoxz43z0015sku21ey5pl4t"},{"post_id":"cjaoxz43i0008sku2oo86456l","tag_id":"cjaoxz43x0010sku2nujwn6sx","_id":"cjaoxz43z0017sku2tt86yyx3"},{"post_id":"cjaoxz43i0008sku2oo86456l","tag_id":"cjaoxz43f0005sku28empxqqf","_id":"cjaoxz43z0018sku2vh4sni73"},{"post_id":"cjaoxz43l000bsku28c4g0og2","tag_id":"cjaoxz43f0005sku28empxqqf","_id":"cjaoxz441001bsku25o2ab8eu"},{"post_id":"cjaoxz43l000bsku28c4g0og2","tag_id":"cjaoxz43y0013sku2txktllox","_id":"cjaoxz441001csku2ujlzyd1e"},{"post_id":"cjaoxz43l000bsku28c4g0og2","tag_id":"cjaoxz43z0016sku2t9712dom","_id":"cjaoxz441001esku2a6g0jeod"},{"post_id":"cjaoxz43l000bsku28c4g0og2","tag_id":"cjaoxz43x0010sku2nujwn6sx","_id":"cjaoxz441001fsku2m6g9dqcy"},{"post_id":"cjaoxz43n000csku2rxmm269y","tag_id":"cjaoxz43f0005sku28empxqqf","_id":"cjaoxz442001gsku27etfy6aq"},{"post_id":"cjaoxz43n000csku2rxmm269y","tag_id":"cjaoxz440001asku24v8535yp","_id":"cjaoxz442001hsku2jjgx9kno"},{"post_id":"cjaoxz43n000csku2rxmm269y","tag_id":"cjaoxz441001dsku2wavqemlc","_id":"cjaoxz442001isku2z11mmo56"}],"Tag":[{"name":"iOS","_id":"cjaoxz43f0005sku28empxqqf"},{"name":"KVC","_id":"cjaoxz43i000asku2ciaoslab"},{"name":"SDWebImage","_id":"cjaoxz43s000lsku2g095jocz"},{"name":"Block","_id":"cjaoxz43u000tsku2b51avfy7"},{"name":"Swift","_id":"cjaoxz43v000usku2vo9wattc"},{"name":"Class","_id":"cjaoxz43w000xsku2ntpl7u2d"},{"name":"Enum","_id":"cjaoxz43x000ysku27gzab7fr"},{"name":"Struct","_id":"cjaoxz43x000zsku2tt7eqbqm"},{"name":"内存","_id":"cjaoxz43x0010sku2nujwn6sx"},{"name":"Xcode","_id":"cjaoxz43y0013sku2txktllox"},{"name":"Instruments","_id":"cjaoxz43z0016sku2t9712dom"},{"name":"TableView","_id":"cjaoxz440001asku24v8535yp"},{"name":"优化","_id":"cjaoxz441001dsku2wavqemlc"}]}}