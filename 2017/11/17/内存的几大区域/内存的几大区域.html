<p>title: 内存的几大区域<br>date: 2017-11-17 17:51:33</p>
<h2 id="tags-iOS"><a href="#tags-iOS" class="headerlink" title="tags: iOS"></a>tags: iOS</h2><h1 id="内存的几大区域"><a href="#内存的几大区域" class="headerlink" title="内存的几大区域"></a>内存的几大区域</h1><h2 id="1-栈区-stack"><a href="#1-栈区-stack" class="headerlink" title="1. 栈区(stack)"></a>1. 栈区(stack)</h2><blockquote>
<p>栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点时有限制，数据不灵活。［先进后出］</p>
</blockquote>
<h5 id="栈空间分静态分配-和动态分配两种。"><a href="#栈空间分静态分配-和动态分配两种。" class="headerlink" title="栈空间分静态分配 和动态分配两种。"></a>栈空间分静态分配 和动态分配两种。</h5><blockquote>
<p>静态分配是编译器完成的，比如自动变量(auto)的分配。<br>动态分配由alloca函数完成。<br>栈的动态分配无需释放(是自动的)，也就没有释放函数。<br>为可移植的程序起见，栈的动态分配操作是不被鼓励的。</p>
</blockquote>
<h2 id="2-堆区-heap"><a href="#2-堆区-heap" class="headerlink" title="2. 堆区(heap)"></a>2. 堆区(heap)</h2><blockquote>
<p>堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。   </p>
</blockquote>
<h5 id="优点是灵活方便，数据适应面广泛，但是效率有一定降低。"><a href="#优点是灵活方便，数据适应面广泛，但是效率有一定降低。" class="headerlink" title="优点是灵活方便，数据适应面广泛，但是效率有一定降低。"></a>优点是灵活方便，数据适应面广泛，但是效率有一定降低。</h5><blockquote>
<p>堆是函数库内部数据结构，不一定唯一。<br>不同堆分配的内存无法互相操作。<br>堆的分配总是动态的。</p>
</blockquote>
<h5 id="虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。"><a href="#虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。" class="headerlink" title="虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。"></a>虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。</h5><h2 id="3-全局区-静态区-static"><a href="#3-全局区-静态区-static" class="headerlink" title="3. 全局区(静态区) (static)"></a>3. 全局区(静态区) (static)</h2><blockquote>
<p>全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</p>
<p>注意：全局区又可分为<strong>未初始化全局区</strong>(bss段)和<strong>初始化全局区</strong>(data段)<br> 举例:<br> <code>int a; 未初始化的</code>  <code>int a = 10; 初始化的</code></p>
</blockquote>
<h2 id="4-文字常量区"><a href="#4-文字常量区" class="headerlink" title="4. 文字常量区"></a>4. 文字常量区</h2><blockquote>
<p>文字常量区 存放常量字符串，程序结束后由系统释放；</p>
</blockquote>
<h2 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5. 代码区"></a>5. 代码区</h2><blockquote>
<p>代码区 存放函数的二进制代码</p>
</blockquote>
<p>{% asset_img pic1.jpg 图片来源见水印 %}</p>
<p>{% asset_img pic2.jpg 图片来源见水印 %}</p>
<h4 id="例子代码："><a href="#例子代码：" class="headerlink" title="例子代码："></a>例子代码：</h4><p>{% asset_img pic3.jpg 图片来源见水印 %}</p>
<h2 id="可能被追问的问题一："><a href="#可能被追问的问题一：" class="headerlink" title="可能被追问的问题一："></a>可能被追问的问题一：</h2><blockquote>
<p>1.栈区 (stack [stæk]):<br>由编译器自动分配释放<br>局部变量是保存在栈区的<br>方法调用的实参也是保存在栈区的</p>
<p>2.堆区 (heap [hiːp]):<br>由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧 使用 new 方法创建的对象，被创建对象的所有 成员变量！</p>
<p>3.BSS 段 :<br>程序结束后由系统释放</p>
<p>数据段 :<br>程序结束后由系统释放</p>
<p>代码段:<br>程序结束后由系统释放<br>程序编译链接 后的二进制可执行代码</p>
</blockquote>
<h2 id="可能被追问的问题二："><a href="#可能被追问的问题二：" class="headerlink" title="可能被追问的问题二："></a>可能被追问的问题二：</h2><blockquote>
<p>申请后的系统是如何响应的？</p>
<blockquote>
<p>栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。</p>
<p>注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：<br>1.首先应该知道操作系统有一个记录空闲内存地址的链表。<br>2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。<br>3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</p>
</blockquote>
</blockquote>
<h2 id="可能被追问的问题三："><a href="#可能被追问的问题三：" class="headerlink" title="可能被追问的问题三："></a>可能被追问的问题三：</h2><blockquote>
<p>申请大小的限制是怎样的？</p>
<blockquote>
<p>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br>是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。<br>因此，能从栈获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。<br>这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。<br>堆的大小受限于计算机系统中有效的虚拟内存。<br>由此可见，堆获得的空间比较灵活，也比较大。</p>
</blockquote>
<p>{% asset_img pic4.jpg 图片来源见水印 %}<br> 栈：<br> 由系统自动分配，速度较快，不会产生内存碎片  </p>
<p> 堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便<br> 打个比喻来说：<br> 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br> 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
</blockquote>
